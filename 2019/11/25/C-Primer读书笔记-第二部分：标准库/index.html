<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sjtu-xx.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="8.IO库IO类IO库类型和头文件">
<meta property="og:type" content="article">
<meta property="og:title" content="C-Primer读书笔记-第二部分：标准库">
<meta property="og:url" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/index.html">
<meta property="og:site_name" content="薛轩的个人博客">
<meta property="og:description" content="8.IO库IO类IO库类型和头文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118170043547.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118170058059.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118171455672.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118171509733.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118171704813.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118171744187.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101190540050.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101190558336.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101192902724.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101193255804.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101193430976.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101194839408.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101194856656.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101195041242.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101195050626.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101195207116.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200101195227975.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102190613569.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102191018921.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102192548970.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102214647056.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102215952297.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20200102220158133.png">
<meta property="article:published_time" content="2019-11-25T09:00:37.000Z">
<meta property="article:modified_time" content="2020-11-27T07:45:56.000Z">
<meta property="article:author" content="Xue Xuan">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/image/image-20191118170043547.png">

<link rel="canonical" href="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C-Primer读书笔记-第二部分：标准库 | 薛轩的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">薛轩的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">XueXuan's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Xue Xuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="薛轩的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C-Primer读书笔记-第二部分：标准库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-25 17:00:37" itemprop="dateCreated datePublished" datetime="2019-11-25T17:00:37+08:00">2019-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-27 15:45:56" itemprop="dateModified" datetime="2020-11-27T15:45:56+08:00">2020-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="8-IO库"><a href="#8-IO库" class="headerlink" title="8.IO库"></a>8.IO库</h1><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO库类型和头文件"><a href="#IO库类型和头文件" class="headerlink" title="IO库类型和头文件"></a>IO库类型和头文件</h3><span id="more"></span>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>iostream</td>
<td>istream,wistream从流读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ostream,wostream向流写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>iostream，wiostream读写流</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream,wiftream从文件读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ofstream,wofstream向文件写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>fstream，wfstream读写文件</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream,wistringstream从string读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ostringstream,wostringstream向string写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>stringstream，wstringstream读写流</td>
</tr>
</tbody></table>
<ul>
<li>我们不能拷贝或者对IO对象赋值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2; <span class="comment">//错误：不能赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>; <span class="comment">//错误不能初始化ofstream参数</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2); <span class="comment">//错误：不能拷贝对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将流当作条件使用</span></span><br><span class="line"><span class="keyword">if</span> (cin &gt;&gt; word);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。</p>
</li>
<li><p><img src="image/image-20191118170043547.png" alt="image-20191118170043547"></p>
</li>
<li><p><img src="image/image-20191118170058059.png" alt="image-20191118170058059"></p>
</li>
<li><p>带参数的clear接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复位failbit和badbit，保持其他标识位不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在每个输出操作后，我们可以使用操作符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p>
</li>
<li><p>刷新输出缓冲区</p>
<ul>
<li><p>操作符endl完成换行并刷新缓冲区的工作。</p>
</li>
<li><p>操作符ends向缓冲区插入一个空字符，然后刷新缓冲区。</p>
</li>
<li><p>操作符flush刷新缓冲区，不输出任何额外的字符。</p>
</li>
<li><p>如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操作符。他告诉流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操作符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;  <span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; nounitbuff; <span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>关联输入和输出流</p>
<ul>
<li><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout); <span class="comment">//将cin和cout关联在一起（默认情况下这两者是关联的）</span></span><br></pre></td></tr></table></figure></li>
<li><p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul>
<li><p>使用文件流对象</p>
<ul>
<li><p>创建文件流对象时，可以提供文件名。如果提供文件名，则open会被自动调用；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;  <span class="comment">//构造ifstream并打开给定文件</span></span><br><span class="line">ofstream out;  <span class="comment">//输出文件流out</span></span><br></pre></td></tr></table></figure></li>
<li><p>当一个fstream对象离开其作用域，与之关联的文件会自动关闭。（当一个fstream对象被销毁时，close会被自动调用）</p>
</li>
</ul>
</li>
<li><p>文件模式</p>
<ul>
<li><img src="image/image-20191118171455672.png" alt="image-20191118171455672"></li>
<li><img src="image/image-20191118171509733.png" alt="image-20191118171509733"></li>
<li>只可以对ofstream或fstream设定out模式。</li>
<li>只可以对ifstream或fstream设定in模式。</li>
<li>只有当out也被设定，才可以设定trunct模式</li>
<li>只要trunc没被设定，就可以设定app模式。</li>
<li><img src="image/image-20191118171704813.png" alt="image-20191118171704813"></li>
<li>使用完流要及时close()</li>
</ul>
</li>
</ul>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul>
<li><p>sstream特有的操作</p>
<p><img src="image/image-20191118171744187.png" alt="image-20191118171744187"></p>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PersonInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;PersonInfo&gt; personInfos;</span><br><span class="line">    std::string line,data;</span><br><span class="line"></span><br><span class="line">    std::ifstream inputFile;</span><br><span class="line">    inputFile.<span class="built_in">open</span>(<span class="string">&quot;/Users/xuexuan/Desktop/tmp/test/123&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(std::<span class="built_in">getline</span>(inputFile,line))&#123;</span><br><span class="line">        PersonInfo person;</span><br><span class="line">        <span class="function">std::istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; person.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; data)&#123;</span><br><span class="line">            person.phones.<span class="built_in">push_back</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        personInfos.<span class="built_in">push_back</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item:personInfos)&#123;</span><br><span class="line">        std::ostringstream formatted, badNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums:item.phones)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(nums))&#123;</span><br><span class="line">                formatted &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;nums;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                badNums &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt;nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())&#123;</span><br><span class="line">            std::cout &lt;&lt; item.name &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;formatted.<span class="built_in">str</span>()&lt;&lt;std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            std::cout &lt;&lt; item.name &lt;&lt;<span class="string">&quot;  invalid:&quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9.顺序容器"></a>9.顺序容器</h1><h2 id="顺序容器的类型"><a href="#顺序容器的类型" class="headerlink" title="顺序容器的类型"></a>顺序容器的类型</h2><table>
<thead>
<tr>
<th>容器</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td>string</td>
<td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td>
</tr>
</tbody></table>
<p>vector\deque\list\forward_list\array\string<br>array是一种比内置数组更安全，更容易使用的数组类型。 array支持拷贝与赋值操作。<br>forward_list没有没有size操作。</p>
<h2 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h2><ul>
<li>除非有很好的理由选择其他容器，否则选择vector</li>
<li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list.</li>
<li>如果程序要求随机访问元素，应使用vector或deque</li>
<li>如果程序要求在容器中间插入或删除元素，应使用list或forward_list.</li>
<li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素。则：<ul>
<li>。。。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：迭代器，不使用下标操作，避免随机访问。这样，在必要时选择vector和list都很方便。</p>
</blockquote>
<p>容器操作</p>
<p><img src="image/image-20200101190540050.png" alt="image-20200101190540050"></p>
<p><img src="image/image-20200101190558336.png" alt="image-20200101190558336"></p>
<ul>
<li>新标准库中容器既提供成员版本的swap，也提供非成员版本的swap。<strong>统一使用非成员版本的swap是一个好习惯</strong>。</li>
<li>当不需要写访问时，应使用cbegin和cend</li>
</ul>
<h2 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h2><h3 id="容器定义与初始化"><a href="#容器定义与初始化" class="headerlink" title="容器定义与初始化"></a>容器定义与初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line">C c1 = c2; <span class="comment">// c1和c2必须是相同类型</span></span><br><span class="line">C c&#123;a,b,c&#125;;  </span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b,e)</span></span>;  <span class="comment">//c初始化为迭代器b和e之间的元素的拷贝</span></span><br><span class="line"><span class="comment">// 只有顺序容器才能接受大小参数</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n)</span></span>; <span class="comment">//此函数是explicit的</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n,t)</span></span>;  <span class="comment">//n个t元素</span></span><br></pre></td></tr></table></figure>

<p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器与原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素即可。</p>
<p>虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array无此限制。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><img src="image/image-20200101192902724.png" alt="image-20200101192902724"></p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>在解引用一个迭代器或调用front或back之前检查是否有元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = *c.<span class="built_in">begin</span>(), val2 = c.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序容器中访问元素的操作</p>
<p><img src="image/image-20200101193255804.png" alt="image-20200101193255804"></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="image/image-20200101193430976.png" alt="image-20200101193430976"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><ul>
<li>改变容器大小 c .resize()</li>
</ul>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><ul>
<li>容器操作可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。</li>
<li>管理容量的成员函数</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>c.shrink_to_fit()</td>
<td>将capacity()减小为与size()相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配内存的话，c可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve()</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody></table>
<ul>
<li><p>容器适配器</p>
<p>stack/queue/priority_queue</p>
</li>
<li><p>栈默认基于deque实现。</p>
</li>
</ul>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n、len2和pos2都是无符号值</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cp,n)</span></span>; <span class="comment">//s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(s2,pos2)</span></span>; <span class="comment">//s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;S2.size(),构造函数未定义</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(s2,pos2,len2)</span></span>; <span class="comment">//s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;S2.size(),构造函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符</span></span><br></pre></td></tr></table></figure>

<p>子字符串操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos,n); <span class="comment">//返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0.n的默认值为s.size()-pos,即拷贝从pos开始的所有字符</span></span><br></pre></td></tr></table></figure>

<h3 id="修改string的操作"><a href="#修改string的操作" class="headerlink" title="修改string的操作"></a>修改string的操作</h3><p><img src="image/image-20200101194839408.png" alt="image-20200101194839408"></p>
<p><img src="image/image-20200101194856656.png" alt="image-20200101194856656"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="image/image-20200101195041242.png" alt="image-20200101195041242"></p>
<p><img src="image/image-20200101195050626.png" alt="image-20200101195050626"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="image/image-20200101195207116.png" alt="image-20200101195207116"></p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="image/image-20200101195227975.png" alt="image-20200101195227975"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器，标准库还定义了三个顺序容器适配器：stack，queue和priority_queue。</p>
<h1 id="10-范型算法"><a href="#10-范型算法" class="headerlink" title="10.范型算法"></a>10.范型算法</h1><p>大多数算法定义在algorithm中。标准库还在numeric头文件中定义了一组数值范型算法。泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p><strong>累加算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="number">0</span>) <span class="comment">//accumulate中第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于只读取而不改变元素的算法，通常最好使用cbegin()和cend()</p>
</blockquote>
<p><strong>判等算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span>(roster1.<span class="built_in">cbegin</span>(),roster1.<span class="built_in">cend</span>(),roster2.<span class="built_in">cbegin</span>())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那些只接收一个单一迭代器来表示第二个序列的算法都假定第二个序列至少和第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。</p>
</blockquote>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//将每个元素置0</span></span><br><span class="line"><span class="built_in">fill_n</span>(dest,n,val); <span class="comment">//将从dest开始的n个元素赋予val</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</p>
</blockquote>
<p><strong>back_inserter 插入迭代器</strong></p>
<p>back_inserter定义在头文件iterator中的一个函数。接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。我们常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空向量</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);</span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">//vec中现在有一个元素，值为42</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">0</span>); <span class="comment">//添加10个元素到vec</span></span><br></pre></td></tr></table></figure>



<h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy</span></span><br><span class="line"><span class="comment">//返回目的位置迭代器（递增后）的值</span></span><br><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="built_in"><span class="keyword">sizeof</span></span>(a1)/<span class="built_in"><span class="keyword">sizeof</span></span>(*a1)]</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1),<span class="built_in">end</span>(a1),a2); <span class="comment">//把a1的内容拷贝给a2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//replace</span></span><br><span class="line"><span class="comment">//将ilst中的0替换为42</span></span><br><span class="line"><span class="built_in">replace</span>(ilst.<span class="built_in">begin</span>(),ilst.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replace_copy</span></span><br><span class="line"><span class="comment">//保留原序列不变，将调整后的序列保存在第三个参数所指的位置</span></span><br><span class="line"><span class="built_in">replace_copy</span>(ilst.<span class="built_in">cbegin</span>(),ilst.<span class="built_in">cend</span>(),<span class="built_in">back_inserter</span>(ivec),<span class="number">0</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure>



<h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort</span></span><br><span class="line"><span class="comment">//unique:将不重复的元素放在序列的开始部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按字典排序</span></span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//unique返回 指向不重复区域之后第一个位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//使用vector的eraser删除重复元素</span></span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>类似于sort之类的函数有第二个版本，接受第三个参数，此参数是一个谓词。</p>
<blockquote>
<p>谓词是一个可调用的表达式。其返回结果是一个能用做条件的值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按长度由短至长排列</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//stable_sort</span></span><br><span class="line"><span class="comment">//保持元素原有顺序</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find_if函数</span></span><br><span class="line">接受一个元素，</span><br></pre></td></tr></table></figure>



<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><blockquote>
<p>find_if 函数<br>接受一对迭代器，查找范围内第一个满足特定条件的元素。</p>
</blockquote>
<p><strong>lambda表达式</strong>的形式<code>[capture list](parameter list) -&gt; return type &#123;function body&#125;</code></p>
<blockquote>
<p>一个lambda只有在其捕获列表中捕获一个他所在函数中的局部变量，才能在函数中使用该变量</p>
<p>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void</p>
</blockquote>
<p>lambda<strong>捕获和返回</strong></p>
<ul>
<li><p>如果可能的话，应避免捕获指针或引用</p>
</li>
<li><p>隐式捕获：为了只是编译器推断捕获列表，应在捕获列表中写一个<code>&amp;</code>或<code>=</code>，<code>&amp;</code>告诉编译器采用引用捕获的方式，<code>=</code>告诉编译器采用值捕获的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=](<span class="keyword">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;sz&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果希望改变被捕获的变量，就必须在参数列表开头加上关键字mutable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">//j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指定lambda的返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transform</span></span><br><span class="line"><span class="comment">// 接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。对输入序列中的每个元素调用可调用对象，并将结果写入到目的位置。</span></span><br><span class="line"><span class="comment">// 返回绝对值</span></span><br><span class="line"><span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;v)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">if</span> v&lt;<span class="number">0</span>:<span class="keyword">return</span> -v;<span class="keyword">else</span>:<span class="keyword">return</span> v;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>bind函数位于头文件functional中，绑定格式<code>auto newCallable = bind(callable, arglist)</code>。arglist中的参数可能包含形如<code>_n</code>之类的名字，表示占位符。<code>_1</code>表示newCallable的第一个参数</p>
<blockquote>
<p>使用placeholders名字</p>
<p>名字_n都定义在placeholders命名空间中。这个空间本身定义在std命名空间中</p>
<p>using namespace std::placeholders;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> string &amp;s, string::size_type sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的bind和lambda等价</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">                 [sz](<span class="keyword">const</span> string &amp;a)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> <span class="built_in">check_size</span>(a, sz)&#125;);</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">                 <span class="built_in">bind</span>(check_size,_1,sz));</span><br></pre></td></tr></table></figure>

<p>bind的哪些不是占位符的参数被拷贝到bind返回的可调用对象中。如果我们希望传递给bind一个对象而不拷贝它，就必须使用ref函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(print,<span class="built_in">ref</span>(os),_1,<span class="string">&#x27; &#x27;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="其他迭代器"><a href="#其他迭代器" class="headerlink" title="其他迭代器"></a>其他迭代器</h3><ul>
<li>插入迭代器</li>
<li>流迭代器</li>
<li>反向迭代器</li>
<li>移动迭代器</li>
</ul>
<h4 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h4><p><code>back_inserter</code>、<code>front_inserter</code>、<code>inserter</code></p>
<blockquote>
<p><strong>插入迭代器的工作方式</strong></p>
<p>当调用inserter(c, iter) 时，得到一个迭代器，使用它时，会插入到iter原来所指的元素之前的位置</p>
<p>当调用front_inserter时，元素总是插入到第一个元素之前。</p>
</blockquote>
<h4 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从标准输入中读取数据，存入一个vector中</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>; <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; <span class="comment">//istream尾后迭代器（空表示尾后迭代器）</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++); <span class="comment">//将in_iter中的数据保存在in_iter中并读取下一条数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过copy打印vec中的元素，这比编写循环更简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out_iter);</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><p>递增一个反向迭代器会移动到前一个位置，递减一个反向迭代器会移动到后一个位置。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><table>
<thead>
<tr>
<th>—–</th>
<th>—–</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>只读、不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写、不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody></table>
<p>array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>大多数算法具有如下四种形式之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alg</span>(beg,end,other args)</span><br><span class="line"><span class="built_in">alg</span>(beg,end,dest,other args)</span><br><span class="line"><span class="built_in">alg</span>(beg,end,beg2,other args)</span><br><span class="line"><span class="built_in">alg</span>(beg,end,beg2,end2,other args)</span><br></pre></td></tr></table></figure>

<h4 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h4><p>算法假定：按需要写入数据，不管写入多少元素都是安全的<br>如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已经存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器，或是一个ostream_iterator。</p>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><p>算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载形式传递一个谓词 (unique)</p>
<h4 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a>_if版本的算法</h4><p>接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词的算法都有附加的_if前缀：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);   <span class="comment">//查找输入范围中val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);   <span class="comment">//查找第一个使pred为真的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="区分拷贝元素的版本和不拷贝元素的版本"><a href="#区分拷贝元素的版本和不拷贝元素的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝元素的版本"></a>区分拷贝元素的版本和不拷贝元素的版本</h4><p>写到额外空间的算法都在名字后面附加一个_copy:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg,end);</span><br><span class="line"><span class="built_in">reverse_copy</span>(beg,end,dest);  <span class="comment">//将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure>

<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>list和forward_list成员函数版本的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst.<span class="built_in">merge</span>(lst2);  将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用&lt;运算符</span><br><span class="line">lst.<span class="built_in">merge</span>(lst2,comp); 将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用compare</span><br><span class="line">lst.<span class="built_in">remove</span>(val); 调用erase删除掉与给定值相等的元素</span><br><span class="line">lst.<span class="built_in">reverse</span>();</span><br><span class="line">lst.<span class="built_in">sort</span>();</span><br><span class="line">lst.<span class="built_in">unique</span>();</span><br></pre></td></tr></table></figure>

<h1 id="11-关联容器"><a href="#11-关联容器" class="headerlink" title="11.关联容器"></a>11.关联容器</h1><p><strong>关联容器</strong>支持高效的关键字查找和访问。<br>两个主要的关联容器：<code>set</code>和<code>map</code>。<br>|容器类型|描述|<br>|————-|———|<br>|按关键字有序保存元素||<br>|map|关联数组：保存关键字-值对|<br>|set|关键字即值，即只保存关键字的容器|<br>|multimap|关键字可重复初夏你的map|<br>|multiset|关键字可重复出现的set|<br>|无序集合||<br>|unordered_map|用哈希函数组织的map|<br>|unordered_set|用哈希函数组织的set|<br>|unordered_multimap|哈希组织的map：关键字可重复出现|<br>|unordered_multiset|哈希组织的set：关键字可重复出现|</p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p><strong>使用map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词出现的次数</span></span><br><span class="line">map&lt;string, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;word)&#123;</span><br><span class="line">	++word_count[word];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w:word_count)&#123;</span><br><span class="line">	cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second &lt;&lt; ((w.second&gt;<span class="number">1</span>)?<span class="string">&quot;times&quot;</span>:<span class="string">&quot;time&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个单词出现的次数</span></span><br><span class="line">map&lt;string, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">set&lt;string&gt; exclude = &#123;<span class="string">&quot;The&quot;</span>,<span class="string">&quot;But&quot;</span>,<span class="string">&quot;And&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;but&quot;</span>,<span class="string">&quot;and&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;word)&#123;</span><br><span class="line">	<span class="keyword">if</span> (exclude.<span class="built_in">find</span>(word)==exclude.<span class="built_in">end</span>())</span><br><span class="line">		++ word_count[word];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器支持普通容器的所有操作。不支持顺序容器的位置相关操作（如push_back等）。</p>
<h3 id="关联容器的定义"><a href="#关联容器的定义" class="headerlink" title="关联容器的定义"></a>关联容器的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="keyword">size_t</span>&gt; word_count;  <span class="comment">//空容器</span></span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line">set&lt;string&gt; exclude = &#123;<span class="string">&quot;The&quot;</span>,<span class="string">&quot;But&quot;</span>,<span class="string">&quot;And&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;but&quot;</span>,<span class="string">&quot;and&quot;</span>&#125;;</span><br><span class="line">map&lt;string,string&gt; authors = &#123;&#123;<span class="string">&quot;Joyce&quot;</span>,<span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">						&#123;<span class="string">&quot;Austen&quot;</span>,<span class="string">&quot;Jane&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i!=<span class="number">0</span>; ++i)&#123;</span><br><span class="line">	ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.cbegin(),ivec.cend())</span></span>;</span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.cbegin(),ivec.cend())</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>关键字类型必须定义元素的比较方法<br><strong>使用关键字类型的比较函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当使用decltype来获得一个函数的指针时，必须加上一个*来指出我们要使用一个给定函数类型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.<span class="built_in">isbn</span>()&lt;rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span> *&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair类型定义在头文件utility中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,string&gt; anon;</span><br><span class="line">pair&lt;string,<span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">pair&lt;string,vector&lt;<span class="keyword">int</span>&gt;&gt; line;</span><br><span class="line"></span><br><span class="line">pair&lt;string,string&gt; author&#123;<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joyce&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>pair的数据成员是public的，两个成员分别命名为first和second。</p>
<p><img src="image/image-20200102190613569.png" alt="image-20200102190613569"></p>
<h2 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h2><p>关联容器额外的类型别名</p>
<table>
<thead>
<tr>
<th>——————</th>
<th>——————</th>
</tr>
</thead>
<tbody><tr>
<td>key_type</td>
<td></td>
</tr>
<tr>
<td>mapped_type</td>
<td></td>
</tr>
<tr>
<td>value_type</td>
<td></td>
</tr>
</tbody></table>
<p><img src="image/image-20200102191018921.png" alt="image-20200102191018921"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">cbegin</span>(); <span class="comment">// *map_it是一个指向word_count中第一个元素的引用</span></span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.<span class="built_in">end</span>())&#123;</span><br><span class="line">	count&lt;&lt; map_it -&gt; first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; map_it -&gt; second &lt;&lt; <span class="string">&quot;times&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。</li>
<li>由于关联容器中的元素不能通过他们的关键字进行快速查找，因此对其使用泛型算法是一个坏主意。使用关联容器定义的专用的find成员比泛型find快的多。</li>
<li>实际编程中，如果我们真要对一个关联容器使用算法，要么是将他作为一个源序列，要么是当作一个目的位置。</li>
</ul>
<h3 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line">set1.<span class="built_in">insert</span>(ivec.<span class="built_in">begin</span>(),ivec.<span class="built_in">end</span>());</span><br><span class="line">set1.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word,<span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">size_t</span>&gt;(word,<span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string,<span class="keyword">size_t</span>&gt;::<span class="built_in">value_type</span>(word,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="image/image-20200102192548970.png" alt="image-20200102192548970"></p>
<p>insert具有返回值。对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair,pair的第一个元素为指向具有给定关键字的元素的迭代器，second是一个指示关键字插入成功还是已经存在在容器中的bool值。</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(k); <span class="comment">//删除关键字为k的元素，返回size_t值，指出删除元素的数量</span></span><br><span class="line">c.<span class="built_in">erase</span>(p); <span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">c.<span class="built_in">erase</span>(b,e); <span class="comment">//删除b和e之间的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>不能对multimap和unordered_multimap进行下标操作。</p>
<p>与其他下标运算符不同的是，<strong>如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[k];  <span class="comment">//返回关键字为k的元素；如果k不在map中，则进行值初始化</span></span><br><span class="line">c.<span class="built_in">at</span>(k); <span class="comment">//如果k不在c中抛出out_of_range异常</span></span><br></pre></td></tr></table></figure>

<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">find</span>(k); <span class="comment">//返回一个迭代器，指向第一个关键字为k的元素。如果不存在，指向尾后迭代器。</span></span><br><span class="line">c.<span class="built_in">count</span>(k); <span class="comment">//返回关键字等于k的元素的数量。</span></span><br><span class="line">c.<span class="built_in">lower_bound</span>(k); <span class="comment">//返回一个迭代器，指向第一个关键字不小于k的元素</span></span><br><span class="line">c.<span class="built_in">upper_bound</span>(k); <span class="comment">//返回一个迭代器，指向第一个关键字大于k的元素</span></span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>无序关联容器使用哈希函数。</p>
<p>无序容器在储存上组织为一个桶，每个桶保存零个或多个元素。无序容器使用哈希函数将元素映射到桶。</p>
<p>无序容器的管理操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶接口</span></span><br><span class="line">c.<span class="built_in">bucket_count</span>(); <span class="comment">//正在使用的桶的数目</span></span><br><span class="line">c.<span class="built_in">max_bucket_count</span>();</span><br><span class="line">c.<span class="built_in">bucket_size</span>(n); <span class="comment">//第n个桶中的元素个数</span></span><br><span class="line">c.<span class="built_in">bucket</span>(k);  <span class="comment">//关键字为k的元素在哪个桶中</span></span><br><span class="line"><span class="comment">//桶迭代</span></span><br><span class="line">local_iterator 用来访问桶中元素的迭代器类型</span><br><span class="line">const_local_iterator</span><br><span class="line">c.<span class="built_in">begin</span>(n),c.<span class="built_in">begin</span>(n) 桶n的首元素迭代器和尾后迭代器</span><br><span class="line">c.<span class="built_in">cbegin</span>(n),c.<span class="built_in">cbegin</span>(n)</span><br><span class="line"><span class="comment">//哈希策略</span></span><br><span class="line">c.<span class="built_in">load_factor</span>(); <span class="comment">// 每个桶的平均元素的数量</span></span><br><span class="line">c.<span class="built_in">max_load_factor</span>();</span><br><span class="line">c.<span class="built_in">rehash</span>(n); <span class="comment">//重组存储，使得bucket_count&gt;n而且bucket_count&gt;size/max_load_facor</span></span><br><span class="line">c.<span class="built_in">reserve</span>(n); <span class="comment">//重组存储，是的c可以保存n个元素不必rehash</span></span><br></pre></td></tr></table></figure>



<h1 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12.动态内存"></a>12.动态内存</h1><ul>
<li>静态内存保存局部static对象、类static成员以及定义在任何函数之外的变量。分配在静态内存中的对象由编译器自动创建和销毁。</li>
<li>栈内存用来保存函数内的非static对象。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>或<strong>堆</strong>。程序用堆来储存动态分配的对象。</li>
</ul>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>智能指针定义在头文件memory中</p>
<ul>
<li><code>shared_ptr</code>允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>独占所指向的对象</li>
<li><code>weak_ptr</code>，是一种弱引用，指向shared_ptr所管理的对象</li>
</ul>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_ptr和unique_ptr都支持的操作</span></span><br><span class="line">shared_ptr&lt;T&gt; sp 空智能指针，可以指向T类型的对象</span><br><span class="line">unique_ptr&lt;T&gt; up</span><br><span class="line">p 将p用作一个条件判断，如果p指向一个对象则为<span class="literal">true</span></span><br><span class="line">*p 解引用p</span><br><span class="line">p-&gt;mem</span><br><span class="line">p.<span class="built_in">get</span>()  返回p中保存的指针。要小心使用，如果智能指针释放了对象，返回的指针指向的对象也就消失了</span><br><span class="line"><span class="built_in">swap</span>(p,q) 交换p和q中的指针</span><br><span class="line">    </span><br><span class="line"><span class="comment">//shared_ptr独有的操作</span></span><br><span class="line">make_shared&lt;T&gt; (args)</span><br><span class="line">shared_ptr&lt;T&gt;<span class="built_in">p</span>(q)   p是智能指针q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换成T*</span><br><span class="line">p=q   此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为<span class="number">0</span>，则将其管理的原内存释放。</span><br><span class="line">p.<span class="built_in">unique</span>()  若p.<span class="built_in">use_count</span>()为<span class="number">1</span>返回<span class="literal">true</span>，否则<span class="literal">false</span></span><br><span class="line">p.<span class="built_in">use_count</span>()  返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</span><br></pre></td></tr></table></figure>

<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>); <span class="comment">//</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//进行值初始化</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果将shared_ptr保存在容器中，而后不再需要全部元素，而只要其中的一部分元素，要记得使用erase删除不再需要的那些元素。</p>
</blockquote>
<h4 id="程序使用动态内存的原因"><a href="#程序使用动态内存的原因" class="headerlink" title="程序使用动态内存的原因"></a>程序使用动态内存的原因</h4><ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><h4 id="使用new动态分配和初始化"><a href="#使用new动态分配和初始化" class="headerlink" title="使用new动态分配和初始化"></a>使用new动态分配和初始化</h4><p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">string *ps = <span class="keyword">new</span> string; <span class="comment">//默认初始化为空string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//默认初始化，*pi1的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();  <span class="comment">//值初始化为0,*pi2为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放动态内存</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">//释放空指针总是对的</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>new和delete内存管理常见的三个问题</strong></p>
<p>1.忘记delete内存<br>2.使用已经释放的对象<br>3.同一块内存使用两次</p>
</blockquote>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">42</span>);  <span class="comment">//错误：必须直接初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//正确：进行了值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义和改变shared_ptr的其他方法</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q)</span></span>;  <span class="comment">//p管理内置指针q所指向的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(u)</span></span>;  <span class="comment">//p从unique_ptr u处接管了对象的所有权；将u置空</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q,d)</span></span>;  <span class="comment">//p接管了内置指针q所指对象的所有权。q将使用可调用对象d来代替delete</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(p2,d)</span></span>;  <span class="comment">//p是shared_ptr p2的拷贝，唯一的区别是使用可调用对象d代替delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象。若传递了可选的参数内置指针q，会令q指向p，否则将p置空</span></span><br><span class="line">p.<span class="built_in">reset</span>();  </span><br><span class="line">p.<span class="built_in">reset</span>(q);</span><br><span class="line">p.<span class="built_in">reset</span>(q,d);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>不要混合使用普通指针和智能指针，也不要使用get初始化另一个智能指针或为另一个智能指针赋值</p>
</blockquote>
<h3 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>); <span class="comment">//错误：不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>));  <span class="comment">//正确：p指向一个新对象</span></span><br><span class="line"><span class="comment">//reset会更新引用计数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>智能指针使用规范</strong></p>
<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个之智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了。</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>初始化unique_ptr也必须采用值初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Stearklwjer&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(p2)</span></span>; <span class="comment">//错误：unique_ptr不支持拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr操作</span></span><br><span class="line">unique_ptr&lt;T&gt; u1;  <span class="comment">//空unique_ptr（使用delete释放指针）</span></span><br><span class="line">unique_ptr&lt;T,D&gt; u2;  <span class="comment">//空unique_ptr，使用D释放指针</span></span><br><span class="line"><span class="function">unique_ptr&lt;T,D&gt; <span class="title">u</span><span class="params">(d)</span></span>; <span class="comment">//空unique_ptr,指向类型为T的对象，用类型为D的对象d来代替delete</span></span><br><span class="line">u = <span class="literal">nullptr</span>;  <span class="comment">//释放u所指的对象，将u置空</span></span><br><span class="line">u.<span class="built_in">reset</span>(); </span><br><span class="line">u.<span class="built_in">reset</span>(q);  <span class="comment">//将u指向q</span></span><br><span class="line">u.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>可以拷贝或赋值一个将要销毁的unique_ptr，比如函数返回值。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会释放。</p>
<p><img src="image/image-20200102214647056.png" alt="image-20200102214647056"></p>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，必须调用lock()。</p>
<p><code>if (shared_ptr&lt;int&gt; np = wp.lock())&#123;&#125;</code></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><blockquote>
<p>当一个应用需要可变数量的对象时，使用vector。</p>
</blockquote>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()]; <span class="comment">//pia指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//释放动态数组</span></span><br><span class="line"><span class="keyword">delete</span> [] pia;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理new分配的数组的unique_ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span> []&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不直接管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自己定义的删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span> p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：动态数组类型并不是数组类型</p>
</blockquote>
<p><img src="image/image-20200102215952297.png" alt="image-20200102215952297"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>allocator提供一种内存感知的内存分配方法。</p>
<p><img src="image/image-20200102220158133.png" alt="image-20200102220158133"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/19/c-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6/" rel="prev" title="c++头文件和源文件">
      <i class="fa fa-chevron-left"></i> c++头文件和源文件
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/25/mac%E4%B8%8B%E7%9A%84c-%E5%BA%93%E5%AE%89%E8%A3%85/" rel="next" title="mac下的c++库安装">
      mac下的c++库安装 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#8-IO%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">8.IO库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">IO类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%BA%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">IO库类型和头文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.</span> <span class="nav-text">文件输入输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E6%B5%81"><span class="nav-number">1.3.</span> <span class="nav-text">string流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">9.顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">顺序容器的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text">选择容器的基本原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.3.</span> <span class="nav-text">容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.</span> <span class="nav-text">容器定义与初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">顺序容器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.1.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.2.</span> <span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.3.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.4.4.</span> <span class="nav-text">改变容器大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-number">2.4.5.</span> <span class="nav-text">容器操作可能使迭代器失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.</span> <span class="nav-text">额外的string操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.1.</span> <span class="nav-text">构造string的其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9string%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.</span> <span class="nav-text">修改string的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.3.</span> <span class="nav-text">string搜索操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compare%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.4.</span> <span class="nav-text">compare函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.5.</span> <span class="nav-text">数值转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">容器适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E8%8C%83%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">10.范型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="nav-number">3.0.1.</span> <span class="nav-text">只读算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">3.0.2.</span> <span class="nav-text">写容器元素的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E7%AE%97%E6%B3%95"><span class="nav-number">3.0.3.</span> <span class="nav-text">拷贝算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">3.0.4.</span> <span class="nav-text">重排元素的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">定制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">向算法传递函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">3.1.3.</span> <span class="nav-text">参数绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.1.4.</span> <span class="nav-text">其他迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">插入迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">iostream迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">反向迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">泛型算法结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">算法形参模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E5%8D%95%E4%B8%AA%E7%9B%AE%E6%A0%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">接受单个目标迭代器的算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">接受第二个输入序列的算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">3.2.2.</span> <span class="nav-text">算法命名规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if%E7%89%88%E6%9C%AC%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">_if版本的算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%8B%B7%E8%B4%9D%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%88%E6%9C%AC%E5%92%8C%E4%B8%8D%E6%8B%B7%E8%B4%9D%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">区分拷贝元素的版本和不拷贝元素的版本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">特定容器算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">11.关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">使用关联容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">4.2.</span> <span class="nav-text">关联容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">关联容器的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">4.2.2.</span> <span class="nav-text">关键字类型的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.3.</span> <span class="nav-text">pair类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text">关联容器的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">关联容器迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.4.</span> <span class="nav-text">map的下标操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="nav-number">4.3.5.</span> <span class="nav-text">访问元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">无序容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">5.</span> <span class="nav-text">12.动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.1.</span> <span class="nav-text">动态内存与智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr%E7%B1%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">shared_ptr类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#make-shared%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">make_shared函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">程序使用动态内存的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">5.1.2.</span> <span class="nav-text">直接管理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8new%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">使用new动态分配和初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">5.1.3.</span> <span class="nav-text">shared_ptr和new结合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96shared-ptr%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.4.</span> <span class="nav-text">其他shared_ptr操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr"><span class="nav-number">5.1.5.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-ptr"><span class="nav-number">5.1.6.</span> <span class="nav-text">weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.</span> <span class="nav-text">动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">new和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocator%E7%B1%BB"><span class="nav-number">5.2.2.</span> <span class="nav-text">allocator类</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xue Xuan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Xue Xuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sjtu-xx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sjtu-xx" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xuexuan1997@gmail.com" title="E-Mail → mailto:xuexuan1997@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xue Xuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'eMthrkXxWi9VDSG39hpPXkOi-gzGzoHsz',
      appKey     : '40yWQRY3985h43auodOGjsIQ',
      placeholder: "欢迎畅所欲言",
      avatar     : 'ヾﾉ≧∀≦)o来啊，快活啊!',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
