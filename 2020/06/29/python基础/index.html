<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sjtu-xx.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="零零">
<meta property="og:type" content="article">
<meta property="og:title" content="python基础">
<meta property="og:url" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="薛轩的个人博客">
<meta property="og:description" content="零零">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/1489720931-7116-4AQC6.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/1489720930-6827-Vtk4m.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/1489720930-5882-BO4qO.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/1.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/2.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/3.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/4.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/5.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/6.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/7.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/8.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/9.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/10.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/123.jpg">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/124.jpg">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/125.jpg">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/126.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/127.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/128.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/129.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/130.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/131.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/132.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/133.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/134.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/135.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/136.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/ContractedBlock-1558531626082.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/20161012022913536">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/20161012023013850">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/0_1280550787I2K8.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/0_128055089469yL.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/0_1280551028YEeQ.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/0_1280551287S777.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/0_1280551552NVgW.gif">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/877318-20160731161330028-1449419644.png">
<meta property="og:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/877318-20160817132355390-1351277519.png">
<meta property="article:published_time" content="2020-06-29T11:36:53.000Z">
<meta property="article:modified_time" content="2020-11-27T07:54:18.654Z">
<meta property="article:author" content="Xue Xuan">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/image/1489720931-7116-4AQC6.png">

<link rel="canonical" href="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python基础 | 薛轩的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">薛轩的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">XueXuan's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Xue Xuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="薛轩的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-29 19:36:53" itemprop="dateCreated datePublished" datetime="2020-06-29T19:36:53+08:00">2020-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-27 15:54:18" itemprop="dateModified" datetime="2020-11-27T15:54:18+08:00">2020-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/29/python%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/29/python%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="零零"><a href="#零零" class="headerlink" title="零零"></a>零零</h2><span id="more"></span>
<h3 id="小东西"><a href="#小东西" class="headerlink" title="小东西"></a>小东西</h3><h4 id="星号的作用"><a href="#星号的作用" class="headerlink" title="星号的作用"></a>星号的作用</h4><p>传递实参和定义形参（所谓实参就是调用函数时传入的参数，形参则是定义函数是定义的参数）的时候，你还可以使用两个特殊的语法：<em>、</em>* 。</p>
<p><strong>调用函数时</strong>使用* ，**</p>
<p>test(*args)中 * 的作用：其实就是把序列 args 中的每个元素，当作位置参数传进去。比如上面这个代码，如果 args 等于 (1,2,3) ，那么这个代码就等价于 test(1, 2, 3) 。</p>
<p>test(**kwargs)中 的作用：则是把字典 kwargs 变成关键字参数传递。比如上面这个代码，如果 kwargs 等于 {‘a’:1,’b’:2,’c’:3} ，那这个代码就等价于 test(a=1,b=2,c=3) 。</p>
<p><strong>定义函数参数时</strong>使用* 、**</p>
<p>def test(*args):<br>    …定义函数参数时 * 的含义又要有所不同，在这里 *args 表示把传进来的位置参数都装在元组 args 里面。比如说上面这个函数，调用 test(1, 2, 3) 的话， args 的值就是 (1, 2, 3) 。:</p>
<p>def test(**kwargs):<br>    …类似的，  就是针对关键字参数和字典的了。 调用 test(a=1,b=2,c=3) 的话， kwargs 的值就是 {‘a’:1,’b’:2,’c’:3} 了。</p>
<p>普通的参数定义和传递方式和 * 们都可以和平共处，不过显然 * 必须放在所有位置参数的最后，而 ** 则必须放在所有关键字参数的最后，否则就要产生歧义了。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exec：三个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数一：包含一系列python代码的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数二：全局作用域（字典形式），如果不指定，默认为globals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数三：局部作用域（字典形式），如果不指定，默认为locals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中</span></span><br><span class="line">g=&#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">l=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">global x,z</span></span><br><span class="line"><span class="string">x=100</span></span><br><span class="line"><span class="string">z=200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m=300</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>,g,l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g) <span class="comment">#&#123;&#x27;x&#x27;: 100, &#x27;y&#x27;: 2,&#x27;z&#x27;:200,......&#125;</span></span><br><span class="line"><span class="built_in">print</span>(l) <span class="comment">#&#123;&#x27;m&#x27;: 300&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串编码方式"><a href="#字符串编码方式" class="headerlink" title="字符串编码方式"></a>字符串编码方式</h4><ul>
<li>ASCII：8位二进制数，第一位为0，有128个符号</li>
<li>Unicode：有许多种不同的二进制格式，可以用来表示 Unicode</li>
<li>UTF-8：是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<ul>
<li>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
</li>
</ul>
<h4 id="字符串前的urb字母"><a href="#字符串前的urb字母" class="headerlink" title="字符串前的urb字母"></a>字符串前的urb字母</h4><p>u/U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p>
<p>r/R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p>
<p>b:bytes<br>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes </p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l.pop(<span class="number">2</span>)  按照索引删除</span><br><span class="line">l.remove(<span class="number">2</span>)  按照值删除</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html">https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</a></p>
<ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li>
</ul>
<h5 id="字典浅拷贝实例"><a href="#字典浅拷贝实例" class="headerlink" title="字典浅拷贝实例"></a>字典浅拷贝实例</h5><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><blockquote>
<blockquote>
<blockquote>
<p>a = {1: [1,2,3]}<br>b = a.copy()<br>a, b<br>({1: [1, 2, 3]}, {1: [1, 2, 3]})<br>a[1].append(4)<br>a, b<br>({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>深度拷贝需要引入 copy 模块：</strong></p>
<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><blockquote>
<blockquote>
<blockquote>
<p>import copy<br>c = copy.deepcopy(a)<br>a, c<br>({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})<br>a[1].append(5)<br>a, c<br>({1: [1, 2, 3, 4, 5]}, {1: [1, 2, 3, 4]})</p>
</blockquote>
</blockquote>
</blockquote>
<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>1、<strong>b = a:</strong> 赋值引用，a 和 b 都指向同一个对象。</p>
<p><img src="image/1489720931-7116-4AQC6.png" alt="img"></p>
<p><strong>2、b = a.copy():</strong> 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</p>
<p><img src="image/1489720930-6827-Vtk4m.png" alt="img"></p>
<p><strong>b = copy.deepcopy(a):</strong> 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</p>
<p><img src="image/1489720930-5882-BO4qO.png" alt="img"></p>
<h5 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h5><p>以下实例是使用 copy 模块的 copy.copy（ 浅拷贝 ）和（copy.deepcopy ）:</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-   </span></span><br><span class="line"><span class="keyword">import</span> copy </span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象   </span></span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用 </span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝 </span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝   </span></span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a </span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象   </span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;a = &#x27;</span>, a ) </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;b = &#x27;</span>, b ) </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;c = &#x27;</span>, c ) </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;d = &#x27;</span>, d )</span><br></pre></td></tr></table></figure>
<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;a = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5])</span><br><span class="line">(&#x27;b = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5])</span><br><span class="line">(&#x27;c = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]])</span><br><span class="line">(&#x27;d = &#x27;, [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]])</span><br></pre></td></tr></table></figure>

<h4 id="字典循环"><a href="#字典循环" class="headerlink" title="字典循环"></a>字典循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="print颜色"><a href="#print颜色" class="headerlink" title="print颜色"></a>print颜色</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\033[32;1mcontent\033[0m&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="类设置属性"><a href="#类设置属性" class="headerlink" title="类设置属性"></a>类设置属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setattr</span>(obj,key,value)</span><br><span class="line">obj.__dict__[key] = value</span><br></pre></td></tr></table></figure>


<h2 id="零、文件"><a href="#零、文件" class="headerlink" title="零、文件"></a>零、文件</h2><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/pmghong/1349978">文件读写</a></p>
<p>一读一写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file1,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> x, <span class="built_in">open</span>(file2, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> y:</span><br><span class="line">    y.write(x.read())</span><br></pre></td></tr></table></figure>

<p>有文件句柄，写完文件之后一定要close()</p>
<p>如果直接config.write(open(‘1.txt’,’w’))不用close</p>
<p>文件操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">os.remove(path)   <span class="comment">#删除文件</span></span><br><span class="line">os.removedirs(path)   <span class="comment">#删除空文件夹</span></span><br><span class="line">shutil.rmtree(path)    <span class="comment">#递归删除文件夹</span></span><br></pre></td></tr></table></figure>

<p>shutil</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38640439/article/details/81410116">python 中使用 shutil 实现文件或目录的复制、删除、移动</a></p>
<h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><p>global x 全局<br>nonlocal x上一级的x</p>
<h3 id="1、匿名函数"><a href="#1、匿名函数" class="headerlink" title="1、匿名函数"></a>1、匿名函数</h3><p> lambda函数用完即在内存中删除。<br>  lambda x: x+1<br>   lambda &lt;参数&gt;：&lt;返回值&gt;<br>   lambda只能有一个返回值</p>
<p><strong>应用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func = lambda x: x+1</span><br><span class="line">func(10)</span><br></pre></td></tr></table></figure>

<h3 id="2-函数尾调用"><a href="#2-函数尾调用" class="headerlink" title="2.函数尾调用"></a>2.函数尾调用</h3><p>在函数执行的最后一步调用另一个函数。<br><strong>尾递归调用优化：</strong><br>在函数调用的最后一步进行递归调用</p>
<h3 id="3-高阶函数"><a href="#3-高阶函数" class="headerlink" title="3.高阶函数"></a>3.高阶函数</h3><p>高阶函数：函数的传入参数/返回值是一个函数名<br>（1）map函数<br>依次处理列表中的每一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def test(func, args):</span><br><span class="line">	ret  = []</span><br><span class="line">	for i in args:</span><br><span class="line">		ret.append(func(args))</span><br><span class="line">	return ret</span><br><span class="line">test(lambda x:x+1, args)</span><br></pre></td></tr></table></figure>

<p>map的第一个参数为函数对象（匿名函数或函数名均可），第二个参数为可迭代对象，返回结果为一个list，迭代器，只能迭代一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = map(lambda x:x+1, num_l)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<p>（2）filter函数<br>获取符合条件的数据，返回值为True的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = filter(lambda x:x.endswith(&#x27;sb&#x27;), num_l)</span><br></pre></td></tr></table></figure>

<p>（3）reduce函数<br>将整体的数据进行压缩(处理一个序列，对序列进行合并操作)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">reduce(lambda x,y:x*y,num_list)</span><br><span class="line">reduce(lambda x,y:x*y,num_list, start_num)</span><br></pre></td></tr></table></figure>

<h3 id="4-内置函数"><a href="#4-内置函数" class="headerlink" title="4.内置函数"></a>4.内置函数</h3><p><img src="./image/1.png"></p>
<p>eval()提取字符串中的数据结构<br>可hash的即为不可变数据类型<br>zip()拉链 将两个序列组成元组序列。如果两个序列长度不等，则根据最小长度的序列进行返回。<br>max()可以指定方法<br>list = [{‘name’:’xx’,’age’:30},{‘name’:’yy’,’age’:34}]<br>max(list,key= lambda dict: dict[‘age’])<br>pow(x,y) → x,y<br>pow(x,y,z)  → x**y%z<br>s1 = slice(1,5,2) l = [1,2,3,4,5]  l[s1]<br>sorted(list,key = lambda x:dic[x])</p>
<p>模块就是一个.py文件<br>导入字符串类型的模块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module_name = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">m = <span class="built_in">__import__</span>(module_name)</span><br><span class="line">m.sayhi()</span><br></pre></td></tr></table></figure>



<h2 id="二、文件处理"><a href="#二、文件处理" class="headerlink" title="二、文件处理"></a>二、文件处理</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(file_name,encoding = <span class="string">&#x27;utf-8&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment">#根据操作系统的文件编码方式决定 win：gbk mac:utf-8 </span></span><br><span class="line">f.read() <span class="comment">#读取所有的文件内容</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h3 id="2-打开方式"><a href="#2-打开方式" class="headerlink" title="2.打开方式"></a>2.打开方式</h3><p>w写，r读，a追加(默认以文本方式打开，即wt，rt，at)</p>
<p><strong>读</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.read() <span class="comment">#读取所有的文件内容</span></span><br><span class="line">f.readable()  <span class="comment">#判断是否可读</span></span><br><span class="line">f.readline()  <span class="comment">#读取一行</span></span><br><span class="line">f.readlines()	<span class="comment">#读取所有行，放在一个列表中</span></span><br></pre></td></tr></table></figure>

<p><strong>写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&#x27;w&#x27;模式，无论文件是否存在，新建空文件，进行写操作</span></span><br><span class="line"><span class="comment">#写的参数必须是字符串类型</span></span><br><span class="line">f.write(<span class="string">&#x27;text\n&#x27;</span>)</span><br><span class="line">f.writelines([<span class="string">&#x27;text\n&#x27;</span>,<span class="string">&#x27;text2\n&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>+标识可以同时读写 ，使用：w+,r+,a+均可，均为读写<br>文件没有修改的说法，都是将数据进行覆盖。</p>
<p><strong>使用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name,<span class="string">&#x27;w&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#newline=&#x27;&#x27;读取文件真正的换行符号</span></span><br><span class="line">    <span class="comment">#使用with打开文件不需要进行close()操作</span></span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>

<p>linux中读取文件，vim将文件读取到内存中进行操作，cat不读取到内存中<br><strong>b模式</strong><br>以字节的模型对文件进行操作，不能指定编码方式<br>可用：wb,rb,ab,w+b,r+b,a+b<br>win平台的回车\r\n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.write(<span class="built_in">bytes</span>(<span class="string">&#x27;xx&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">f.write(<span class="string">&#x27;xx&#x27;</span>.encoding(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>其他操作</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f.flush() <span class="comment">#刷新，将内存中的东西写入到文件中</span></span><br><span class="line">f.read(<span class="number">4</span>) <span class="comment">#读取4个字符</span></span><br><span class="line">f.tell() <span class="comment">#光标当前所在的位置（除了read()方法，其余方法以byte为单位）</span></span><br><span class="line">f.seek(<span class="number">1</span>) <span class="comment">#控制光标的移动</span></span><br><span class="line">f.truncate(<span class="number">10</span>) <span class="comment">#截取，留下源文件的前10个bytes </span></span><br></pre></td></tr></table></figure>

<p><strong>seek的高级操作</strong></p>
<p>基于相对位置的seek</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.seek(<span class="number">10</span>,<span class="number">0</span>) <span class="comment">#0：（默认模式）相对于文件开头</span></span><br><span class="line">f.seek(<span class="number">10</span>,<span class="number">1</span>) <span class="comment">#1：相对于上一次的光标位置</span></span><br><span class="line">f.seek(-<span class="number">10</span>,<span class="number">2</span>) <span class="comment">#2：从文件末尾开始seek，第一个参数应该为负数（日志文件中使用）</span></span><br></pre></td></tr></table></figure>

<p>日志文件的读取（读取文件最后一行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    offs = -<span class="number">10</span> <span class="comment">#偏移量的估算</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f.seek(offs,<span class="number">2</span>)</span><br><span class="line">        data = f.readlines()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;文件的最后一行是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(data[-<span class="number">1</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        offs*=<span class="number">2</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p><strong>循环文件的推荐方式</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行一行的获取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h2 id="三-迭代器协议"><a href="#三-迭代器协议" class="headerlink" title="三.迭代器协议"></a>三.迭代器协议</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/7580428.html">林海峰博客</a></p>
<h3 id="1-迭代器协议"><a href="#1-迭代器协议" class="headerlink" title="1.迭代器协议"></a>1.迭代器协议</h3><p>迭代器协议：对象必须提供一个next方法，执行该方法要么返回迭代器中的下一项，要么就引起一个Stopiteration异常，以终止迭代（只能往后，不能往前）</p>
<p>可迭代对象：实现了迭代器协议的对象（实现方法：对象内部定义一个__iter__()方法）</p>
<p>迭代器运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(t)</span><br><span class="line">t.__next__()</span><br></pre></td></tr></table></figure>

<h3 id="2-for循环机制"><a href="#2-for循环机制" class="headerlink" title="2.for循环机制"></a>2.for循环机制</h3><p>for循环的工作原理<br>1：执行in后对象的dic.__iter__()方法，得到一个迭代器对象iter_dic<br>2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码<br>3: 重复过程2，直到捕捉到异常StopIteration,结束循环</p>
<h3 id="3-生成器和列表解析"><a href="#3-生成器和列表解析" class="headerlink" title="3.生成器和列表解析"></a>3.生成器和列表解析</h3><p><strong><font color=red>生成器只能遍历一次</font></strong></p>
<p>只要函数内部包含有yield关键字，那么函数名()的到的结果就是生成器，并且不会执行函数内部代码</p>
<p>生成器自动实现了可迭代协议，不用调用__iter__()方法</p>
<p>三元表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;xx&#x27;</span> <span class="keyword">if</span> name ==<span class="string">&#x27;xuexuan&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;yy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>列表解析(会生成列表，会占用内存)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i &gt;<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>生成器表达式(节省内存)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>sum参数中的加入生成器不需要小括号</p>
<p>yield的作用：</p>
<ol>
<li>相当于return控制函数的返回值，x = yield num</li>
</ol>
<p>2）接受send传过来的值 x = yield  test().send(value)</p>
<p>3）函数中有yield，则调用func()不会执行函数中的内容，使用next()</p>
<h2 id="四、装饰器"><a href="#四、装饰器" class="headerlink" title="四、装饰器"></a>四、装饰器</h2><p>本质就是函数，功能是为其他函数添加附加功能</p>
<p>装饰器 = 高阶函数 + 函数嵌套 + 闭包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">func1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> func1(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>@func2相当于 func1 = func2(func1)</p>
<p>带参数的装饰器，外面添加一层</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span>(<span class="params">para</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">func1</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        	func1(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">   	<span class="keyword">return</span> func2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-原则"><a href="#1-原则" class="headerlink" title="1.原则"></a>1.原则</h3><p>（1）不修改被修饰函数的运行方式<br>（2）不修改被修饰函数的源代码</p>
<h3 id="解压序列"><a href="#解压序列" class="headerlink" title="*解压序列"></a>*解压序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">78</span>,<span class="number">687</span>,<span class="number">9</span>,<span class="number">87987</span>,<span class="number">987</span>,<span class="number">78</span>,<span class="number">7</span>]</span><br><span class="line">a,*_,c = l  <span class="comment"># *_去掉中间的元素</span></span><br><span class="line">a,*b,c = l  <span class="comment"># 将中间的元素储存在b中</span></span><br><span class="line">a,b = b,a <span class="comment"># 交换两个变量</span></span><br></pre></td></tr></table></figure>

<h2 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yuanchenqi/articles/5732581.html">http://www.cnblogs.com/yuanchenqi/articles/5732581.html</a></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>(1) from a import b  会执行a中所有的语句<br>(2) sys path获取 import的路径<br>(3) input()接受str，eval()取出<br>(4) os.rename(xx.bak)备份<br>(5) tag（执行标记）的用法<br>(6) from a import * 不推荐<br>(7) 程序入口一般bin.py<br>(8) main.py:逻辑相关函数<br>(9)from a import * 不会导入下划线开头的属性</p>
<p>临时修改环境变量，<code>sys.path.append()</code></p>
<h3 id="1-内置模块"><a href="#1-内置模块" class="headerlink" title="1.内置模块"></a>1.内置模块</h3><p>time,sys等模块是C语言实现的，嵌入到python解释器中，调用时一定会有限调用。</p>
<h4 id="1-1-time模块"><a href="#1-1-time模块" class="headerlink" title="1.1 time模块"></a>1.1 time模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间戳</span></span><br><span class="line">time.time() <span class="comment">#1970年1月1日0点至今的秒数，用于计时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间</span></span><br><span class="line">time.localtime() <span class="comment">#返回结构化时间（当地时间）</span></span><br><span class="line">time.localtime().tm_year <span class="comment">#返回年份（tm_mon:月,tm_wday:星期，tm_hour:小时等）</span></span><br><span class="line">time.gmtime() <span class="comment">#返回结构化时间（0时区的时间）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间转化为时间戳</span></span><br><span class="line">time.mktime(time.localtime())</span><br><span class="line"><span class="comment">#结构化时间转化为字符串时间</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>,time.localtime())  <span class="comment">#%X为时间</span></span><br><span class="line"><span class="comment">#字符串时间转成结构化时间</span></span><br><span class="line">time.strptime(<span class="string">&#x27;2016:12:24:17:50:36&#x27;</span>,<span class="string">&#x27;%Y:%m:%d:%X&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接给定直观的时间</span></span><br><span class="line">time.asctime()  <span class="comment">#结构化时间转化为字符串时间</span></span><br><span class="line">time.ctime()  <span class="comment">#时间戳转换为字符串时间</span></span><br><span class="line"></span><br><span class="line">time.sleep()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="./image/2.png"></p>
<p><img src="./image/3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime.datetime.now() <span class="comment"># year-month-day h:m:s</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-random模块"><a href="#1-2-random模块" class="headerlink" title="1.2 random模块"></a>1.2 random模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">random</span><br><span class="line"><span class="built_in">print</span>(random.random())<span class="comment">#(0,1)----float</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment">#[1,3]</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#[1,3) -- int</span></span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]]))<span class="comment">#23</span></span><br><span class="line"><span class="built_in">print</span>(random.sample([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>))<span class="comment">#[[4, 5], &#x27;23&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#1.927109612082716</span></span><br><span class="line"><span class="built_in">print</span>(random.shuffle([<span class="number">123</span>,<span class="number">4</span>,<span class="number">5234</span>,<span class="number">5</span>])) <span class="comment">#洗牌</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-os模块"><a href="#1-3-os模块" class="headerlink" title="1.3 os模块"></a>1.3 os模块</h4><p>os模块只能删除空文件夹，不能删除非空文件夹</p>
<p>删除文件用os.remove()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.getpid()	获得进程的进程<span class="built_in">id</span></span><br><span class="line">os.getppid() 获得父进程的进程<span class="built_in">id</span></span><br><span class="line">os.chdir(<span class="string">&quot;dirname&quot;</span>)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(<span class="string">&#x27;..&#x27;</span>)</span><br><span class="line">os.makedirs(<span class="string">&#x27;dirname1/dirname2&#x27;</span>)    可生成多层递归目录</span><br><span class="line">os.removedirs(<span class="string">&#x27;dirname1&#x27;</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(<span class="string">&#x27;dirname&#x27;</span>)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(<span class="string">&#x27;dirname&#x27;</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>,<span class="string">&quot;newname&quot;</span>)  重命名文件/目录</span><br><span class="line">os.stat(<span class="string">&#x27;path/filename&#x27;</span>)  <span class="comment">#获取文件/目录信息 st_atime上一次查看时间 st_mtime上一次修改时间，st_ctime创建时间</span></span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为<span class="string">&quot;\\&quot;</span>,Linux下为<span class="string">&quot;/&quot;</span></span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为<span class="string">&quot;\r\n&quot;</span>,Linux下为<span class="string">&quot;\n&quot;</span></span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;<span class="string">&#x27;nt&#x27;</span>; Linux-&gt;<span class="string">&#x27;posix&#x27;</span></span><br><span class="line">os.system(<span class="string">&quot;bash command&quot;</span>)  运行shell命令，直接显示  (推荐使用：subprocess模块)</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回<span class="literal">True</span>；如果path不存在，返回<span class="literal">False</span></span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回<span class="literal">True</span></span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回<span class="literal">True</span>。否则返回<span class="literal">False</span></span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回<span class="literal">True</span>。否则返回<span class="literal">False</span></span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure>

<h4 id="1-4-sys模块"><a href="#1-4-sys模块" class="headerlink" title="1.4 sys模块"></a>1.4 sys模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数<span class="type">List</span>，第一个元素是程序本身路径（文件名）</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(<span class="number">0</span>)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.maxint         最大的Int值</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform       返回操作系统平台名称</span><br><span class="line">sys.stdout.write(<span class="string">&#x27;#&#x27;</span>)  向屏幕显示相应的内容</span><br></pre></td></tr></table></figure>

<p>进度条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout.write(&#x27;#&#x27;)  #写入缓存</span><br><span class="line">sys.stdout.flush()  #将缓存中的文件显示在屏幕</span><br></pre></td></tr></table></figure>

<h4 id="1-5-Json-amp-Pickel"><a href="#1-5-Json-amp-Pickel" class="headerlink" title="1.5 Json&amp;Pickel"></a>1.5 Json&amp;Pickel</h4><ul>
<li><p>json可以进行任何语言间的数据交换，将变量改变为字符串。最多储存到函数级别</p>
</li>
<li><p>只要是js字符串就可以被loads，不一定需要dump</p>
</li>
<li><p>Pickle写入文件需要wb模式，</p>
<p><strong>python中对象依托于类存在，pickle load时必须有相应的类才能load</strong></p>
</li>
</ul>
<p><strong>序列化</strong></p>
<p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<p><strong>json</strong></p>
<p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<p><img src="./image/4.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------序列化</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">dic=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alvin&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dic))<span class="comment">#&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"> </span><br><span class="line">j=json.dumps(dic)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(j))<span class="comment">#&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">  </span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;序列化对象&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(j)  <span class="comment">#-------------------等价于json.dump(dic,f)</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#-----------------------------反序列化&lt;br&gt;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;序列化对象&#x27;</span>)</span><br><span class="line">data=json.loads(f.read())<span class="comment">#  等价于data=json.load(f)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Pickle与json的用法完全相同</li>
</ul>
<p>Pickle是python特有的，支持的数据类型更多。</p>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h4 id="1-5-shelve"><a href="#1-5-shelve" class="headerlink" title="1.5 shelve"></a>1.5 shelve</h4><p>open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line">f = shelve.open(r&#x27;shelve.txt&#x27;)</span><br><span class="line"></span><br><span class="line"># f[&#x27;stu1_info&#x27;]=&#123;&#x27;name&#x27;:&#x27;alex&#x27;,&#x27;age&#x27;:&#x27;18&#x27;&#125;</span><br><span class="line"># f[&#x27;stu2_info&#x27;]=&#123;&#x27;name&#x27;:&#x27;alvin&#x27;,&#x27;age&#x27;:&#x27;20&#x27;&#125;</span><br><span class="line"># f[&#x27;school_info&#x27;]=&#123;&#x27;website&#x27;:&#x27;oldboyedu.com&#x27;,&#x27;city&#x27;:&#x27;beijing&#x27;&#125;</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># f.close()</span><br><span class="line"></span><br><span class="line">print``(f.get(``&#x27;stu_info&#x27;``)[``&#x27;age&#x27;``])</span><br></pre></td></tr></table></figure>

<h4 id="1-6-XML模块"><a href="#1-6-XML模块" class="headerlink" title="1.6 XML模块"></a>1.6 XML模块</h4><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>操作xml</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(<span class="string">&quot;xmltest.xml&quot;</span>) <span class="comment">#解析</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"><span class="built_in">print</span>(root.tag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#遍历xml文档</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root:</span><br><span class="line">    <span class="built_in">print</span>(child.tag, child.attrib)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> child:</span><br><span class="line">        <span class="built_in">print</span>(i.tag,i.text)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#只遍历year 节点</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;year&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(node.tag,node.text)</span><br><span class="line"><span class="comment">#---------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(<span class="string">&quot;xmltest.xml&quot;</span>)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;year&#x27;</span>):</span><br><span class="line">    new_year = <span class="built_in">int</span>(node.text) + <span class="number">1</span></span><br><span class="line">    node.text = <span class="built_in">str</span>(new_year) <span class="comment">#修改文本</span></span><br><span class="line">    node.<span class="built_in">set</span>(<span class="string">&quot;updated&quot;</span>,<span class="string">&quot;yes&quot;</span>) <span class="comment">#设置属性</span></span><br><span class="line">tree.write(<span class="string">&quot;xmltest.xml&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#删除node</span></span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">&#x27;country&#x27;</span>):</span><br><span class="line">   rank = <span class="built_in">int</span>(country.find(<span class="string">&#x27;rank&#x27;</span>).text)</span><br><span class="line">   <span class="keyword">if</span> rank &gt; <span class="number">50</span>:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(<span class="string">&#x27;output.xml&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>创建xml文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(<span class="string">&quot;namelist&quot;</span>)</span><br><span class="line">name = ET.SubElement(new_xml,<span class="string">&quot;name&quot;</span>,attrib=&#123;<span class="string">&quot;enrolled&quot;</span>:<span class="string">&quot;yes&quot;</span>&#125;)</span><br><span class="line">age = ET.SubElement(name,<span class="string">&quot;age&quot;</span>,attrib=&#123;<span class="string">&quot;checked&quot;</span>:<span class="string">&quot;no&quot;</span>&#125;)</span><br><span class="line">sex = ET.SubElement(name,<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">sex.text = <span class="string">&#x27;33&#x27;</span></span><br><span class="line">name2 = ET.SubElement(new_xml,<span class="string">&quot;name&quot;</span>,attrib=&#123;<span class="string">&quot;enrolled&quot;</span>:<span class="string">&quot;no&quot;</span>&#125;)</span><br><span class="line">age = ET.SubElement(name2,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">age.text = <span class="string">&#x27;19&#x27;</span></span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) <span class="comment">#生成文档对象</span></span><br><span class="line">et.write(<span class="string">&quot;test.xml&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>,xml_declaration=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) <span class="comment">#打印生成的格式</span></span><br></pre></td></tr></table></figure>

<h4 id="1-7-re模块"><a href="#1-7-re模块" class="headerlink" title="1.7 re模块"></a>1.7 re模块</h4><p>正则表达式</p>
<p>字符匹配（普通字符，元字符）：</p>
<p>1 普通字符：大多数字符和字母都会和自身匹配<br>              &gt;&gt;&gt; re.findall(‘alvin’,’yuanaleSxalexwupeiqi’)<br>                      [‘alvin’] </p>
<p>2 元字符：. ^ $ * + ? { } [ ] | ( ) \</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">. 通配符（一个字符）</span><br><span class="line">^ 以xxx开头</span><br><span class="line">$ 以xxx结尾</span><br><span class="line">*+?&#123;&#125;</span><br><span class="line">* 按照紧挨的字符重复 0~∞次(注意是0次开始)</span><br><span class="line">+ 按照紧挨的字符重复 1~∞次(注意是1次开始)</span><br><span class="line">? 按照紧挨的字符重复 0或1次</span><br><span class="line">&#123;&#125; 按照紧挨的字符重复 &#123;0,&#125;:*   &#123;1,&#125;:+</span><br><span class="line"></span><br><span class="line">*+?都是贪婪匹配，后面加?为变为惰性匹配</span><br><span class="line"></span><br><span class="line">元字符之转义符\</span><br><span class="line">反斜杠后边跟元字符去除特殊功能,比如\.</span><br><span class="line">反斜杠后边跟普通字符实现特殊功能,比如\d</span><br><span class="line"></span><br><span class="line">\d  匹配任何十进制数；它相当于类 [0-9]。</span><br><span class="line">\D 匹配任何非数字字符；它相当于类 [^0-9]。</span><br><span class="line">\s  匹配任何空白字符；它相当于类 [ \t\n\r\f\v]。</span><br><span class="line">\S 匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</span><br><span class="line">\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</span><br><span class="line">\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</span><br><span class="line">\b  匹配一个特殊字符边界，比如空格 ，&amp;，＃等</span><br><span class="line"></span><br><span class="line">在“”中使用转义字符时，需要进行r&quot;&quot;.</span><br><span class="line"></span><br><span class="line">python str --&gt; python解释器---&gt;re层&quot;&quot;进行匹配</span><br><span class="line">#-----------------------------eg1:</span><br><span class="line">import re</span><br><span class="line">ret=re.findall(&#x27;c\l&#x27;,&#x27;abc\le&#x27;)</span><br><span class="line">print(ret)#[]</span><br><span class="line">ret=re.findall(&#x27;c\\l&#x27;,&#x27;abc\le&#x27;)</span><br><span class="line">print(ret)#[]</span><br><span class="line">ret=re.findall(&#x27;c\\\\l&#x27;,&#x27;abc\le&#x27;)</span><br><span class="line">print(ret)#[&#x27;c\\l&#x27;]</span><br><span class="line">ret=re.findall(r&#x27;c\\l&#x27;,&#x27;abc\le&#x27;)</span><br><span class="line">print(ret)#[&#x27;c\\l&#x27;]</span><br><span class="line"> </span><br><span class="line">#-----------------------------eg2:</span><br><span class="line">#之所以选择\b是因为\b在ASCII表中是有意义的</span><br><span class="line">m = re.findall(&#x27;\bblow&#x27;, &#x27;blow&#x27;)</span><br><span class="line">print(m)</span><br><span class="line">m = re.findall(r&#x27;\bblow&#x27;, &#x27;blow&#x27;)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<p><strong>[] 字符集</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------字符集[]</span></span><br><span class="line">ret=re.findall(<span class="string">&#x27;a[bc]d&#x27;</span>,<span class="string">&#x27;acd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;acd&#x27;]</span></span><br><span class="line"> </span><br><span class="line">ret=re.findall(<span class="string">&#x27;[a-z]&#x27;</span>,<span class="string">&#x27;acd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []没有特殊符号</span></span><br><span class="line">ret=re.findall(<span class="string">&#x27;[.*+]&#x27;</span>,<span class="string">&#x27;a.cd+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;.&#x27;, &#x27;+&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#在字符集里有功能的符号: - ^ \</span></span><br><span class="line"><span class="comment"># - 范围</span></span><br><span class="line">ret=re.findall(<span class="string">&#x27;[1-9]&#x27;</span>,<span class="string">&#x27;45dha3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;4&#x27;, &#x27;5&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"><span class="comment"># ^ 非</span></span><br><span class="line">ret=re.findall(<span class="string">&#x27;[^ab]&#x27;</span>,<span class="string">&#x27;45bdha3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;4&#x27;, &#x27;5&#x27;, &#x27;d&#x27;, &#x27;h&#x27;, &#x27;3&#x27;]</span></span><br><span class="line">  </span><br><span class="line">ret=re.findall(<span class="string">&#x27;[\d]&#x27;</span>,<span class="string">&#x27;45bdha3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;4&#x27;, &#x27;5&#x27;, &#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>|  或</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret=re.search(<span class="string">&#x27;(ab)|\d&#x27;</span>,<span class="string">&#x27;rabhdg8sd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret.group())<span class="comment">#ab</span></span><br></pre></td></tr></table></figure>

<p>（）分组</p>
<p>当匹配中有分组时，findall优先返回分组中的匹配机制，</p>
<p>如果要返回所有的匹配结果，使用(?:xxxxx)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m = re.findall(<span class="string">r&#x27;(ad)+&#x27;</span>, <span class="string">&#x27;add&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"> </span><br><span class="line">m = re.findall(<span class="string">&#x27;(?:abc)+&#x27;</span>,<span class="string">&#x27;abcabcabc&#x27;</span>) <span class="comment">#abcabcabc</span></span><br><span class="line">    </span><br><span class="line">ret=re.search(<span class="string">&#x27;(?P&lt;id&gt;\d&#123;2&#125;)/(?P&lt;name&gt;\w&#123;3&#125;)&#x27;</span>,<span class="string">&#x27;23/com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret.group())<span class="comment">#23/com</span></span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="string">&#x27;id&#x27;</span>))<span class="comment">#23</span></span><br></pre></td></tr></table></figure>

<p>re下的常用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">re.findall(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;alvin yuan&#x27;</span>)    <span class="comment">#返回所有满足匹配条件的结果,放在列表里</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">re.search(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;alvin yuan&#x27;</span>).group()  <span class="comment">#函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">re.match(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>).group()     <span class="comment">#同search,不过尽在字符串开始处进行匹配，返回的是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">ret=re.split(<span class="string">&#x27;[ab]&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>)     <span class="comment">#先按&#x27;a&#x27;分割得到&#x27;&#x27;和&#x27;bcd&#x27;,在对&#x27;&#x27;和&#x27;bcd&#x27;分别按&#x27;b&#x27;分割</span></span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#[&#x27;&#x27;, &#x27;&#x27;, &#x27;cd&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#5 替换</span></span><br><span class="line">ret=re.sub(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;alvin5yuan6&#x27;</span>,<span class="number">1</span>)  <span class="comment">#匹配的次数</span></span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#alvinabcyuan6</span></span><br><span class="line">ret=re.subn(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;alvin5yuan6&#x27;</span>)  <span class="comment">#返回元组，一为结果，二为匹配的次数</span></span><br><span class="line"><span class="built_in">print</span>(ret)<span class="comment">#(&#x27;alvinabcyuanabc&#x27;, 2)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#6 模板</span></span><br><span class="line">obj=re.<span class="built_in">compile</span>(<span class="string">&#x27;\d&#123;3&#125;&#x27;</span>)</span><br><span class="line">ret=obj.search(<span class="string">&#x27;abc123eeee&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret.group())<span class="comment">#123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret=re.finditer(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;ds3sy4784a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)        <span class="comment">#&lt;callable_iterator object at 0x10195f940&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret).group())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret).group())</span><br></pre></td></tr></table></figure>

<h4 id="1-8-logging模块"><a href="#1-8-logging模块" class="headerlink" title="1.8 logging模块"></a>1.8 logging模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"><span class="comment"># 级别从低到高</span></span><br><span class="line">logging.debug(<span class="string">&#x27;debug message&#x27;</span>)  </span><br><span class="line">logging.info(<span class="string">&#x27;info message&#x27;</span>)  </span><br><span class="line">logging.warning(<span class="string">&#x27;warning message&#x27;</span>)  </span><br><span class="line">logging.error(<span class="string">&#x27;error message&#x27;</span>)  </span><br><span class="line">logging.critical(<span class="string">&#x27;critical message&#x27;</span>)  </span><br></pre></td></tr></table></figure>

<p>默认情况下<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/11">Python</a>的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>二  <strong>灵活配置日志级别，日志格式，输出位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import logging  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG,  </span><br><span class="line">                    format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;,  </span><br><span class="line">                    datefmt=&#x27;%a, %d %b %Y %H:%M:%S&#x27;,  </span><br><span class="line">                    filename=&#x27;/tmp/test.log&#x27;,  </span><br><span class="line">                    filemode=&#x27;w&#x27;)  </span><br><span class="line">  </span><br><span class="line">logging.debug(&#x27;debug message&#x27;)  </span><br><span class="line">logging.info(&#x27;info message&#x27;)  </span><br><span class="line">logging.warning(&#x27;warning message&#x27;)  </span><br><span class="line">logging.error(&#x27;error message&#x27;)  </span><br><span class="line">logging.critical(&#x27;critical message&#x27;)</span><br></pre></td></tr></table></figure>

<p>  在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有<br>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。<br>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>format：指定handler使用的日志显示格式。<br>datefmt：指定日期时间格式。<br>level：设置rootlogger（后边会讲解具体概念）的日志级别<br>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：<br>%(name)s Logger的名字<br>%(levelno)s 数字形式的日志级别<br>%(levelname)s 文本形式的日志级别<br>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有<br>%(filename)s 调用日志输出函数的模块的文件名<br>%(module)s 调用日志输出函数的模块名<br>%(funcName)s 调用日志输出函数的函数名<br>%(lineno)d 调用日志输出函数的语句所在的代码行<br>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示<br>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数<br>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒<br>%(thread)d 线程ID。可能没有<br>%(threadName)s 线程名。可能没有<br>%(process)d 进程ID。可能没有<br>%(message)s用户输出的消息  </p>
<p><strong>三  logger对象</strong></p>
<p>​    上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）</p>
<p>​     先看一个最简单的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"><span class="comment"># 创建一个handler，用于写入日志文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">&#x27;test.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个handler，用于输出到控制台</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh) <span class="comment">#logger对象可以添加多个fh和ch对象</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;logger debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;logger info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;logger warning message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;logger error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;logger critical message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>四、两个logger对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line">logger1 = logging.getLogger(<span class="string">&#x27;mylogger&#x27;</span>)</span><br><span class="line">logger1.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logger2 = logging.getLogger(<span class="string">&#x27;mylogger&#x27;</span>) <span class="comment">#与logger名称相同，为同一个对象</span></span><br><span class="line">logger2.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">logger1.addHandler(fh)</span><br><span class="line">logger1.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger2.addHandler(fh)</span><br><span class="line">logger2.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger1.debug(<span class="string">&#x27;logger1 debug message&#x27;</span>)</span><br><span class="line">logger1.info(<span class="string">&#x27;logger1 info message&#x27;</span>)</span><br><span class="line">logger1.warning(<span class="string">&#x27;logger1 warning message&#x27;</span>)</span><br><span class="line">logger1.error(<span class="string">&#x27;logger1 error message&#x27;</span>)</span><br><span class="line">logger1.critical(<span class="string">&#x27;logger1 critical message&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">logger2.debug(<span class="string">&#x27;logger2 debug message&#x27;</span>)</span><br><span class="line">logger2.info(<span class="string">&#x27;logger2 info message&#x27;</span>)</span><br><span class="line">logger2.warning(<span class="string">&#x27;logger2 warning message&#x27;</span>)</span><br><span class="line">logger2.error(<span class="string">&#x27;logger2 error message&#x27;</span>)</span><br><span class="line">logger2.critical(<span class="string">&#x27;logger2 critical message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>(1)我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？</p>
<p>​       原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。</p>
<p>(2)为什么logger1、logger2对应的每个输出分别显示两次?<br>这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。</p>
<h4 id="1-9-configparser模块"><a href="#1-9-configparser模块" class="headerlink" title="1.9 configparser模块"></a>1.9 configparser模块</h4><p><strong>好多软件的常见文档格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line">  </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line">  </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure>

<p>如果想用python生成一个这样的文档怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line">  </span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&quot;DEFAULT&quot;] = &#123;&#x27;ServerAliveInterval&#x27;: &#x27;45&#x27;,</span><br><span class="line">                      &#x27;Compression&#x27;: &#x27;yes&#x27;,</span><br><span class="line">                     &#x27;CompressionLevel&#x27;: &#x27;9&#x27;&#125;</span><br><span class="line">  </span><br><span class="line">config[&#x27;bitbucket.org&#x27;] = &#123;&#125;</span><br><span class="line">config[&#x27;bitbucket.org&#x27;][&#x27;User&#x27;] = &#x27;hg&#x27;</span><br><span class="line">config[&#x27;topsecret.server.com&#x27;] = &#123;&#125;</span><br><span class="line">topsecret = config[&#x27;topsecret.server.com&#x27;]</span><br><span class="line">topsecret[&#x27;Host Port&#x27;] = &#x27;50022&#x27;     # mutates the parser</span><br><span class="line">topsecret[&#x27;ForwardX11&#x27;] = &#x27;no&#x27;  # same here</span><br><span class="line">config[&#x27;DEFAULT&#x27;][&#x27;ForwardX11&#x27;] = &#x27;yes&#x27;&lt;br&gt;</span><br><span class="line">with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as configfile:</span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure>

<p><strong>config section名称不区分大小写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------查</span></span><br><span class="line"><span class="built_in">print</span>(config.sections())   <span class="comment">#[]</span></span><br><span class="line">config.read(<span class="string">&#x27;example.ini&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(config.sections())   <span class="comment">#[&#x27;bitbucket.org&#x27;, &#x27;topsecret.server.com&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bytebong.com&#x27;</span> <span class="keyword">in</span> config)<span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;bitbucket.org&#x27;</span>][<span class="string">&#x27;User&#x27;</span>]) <span class="comment"># hg</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;DEFAULT&#x27;</span>][<span class="string">&#x27;Compression&#x27;</span>]) <span class="comment">#yes</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;topsecret.server.com&#x27;</span>][<span class="string">&#x27;ForwardX11&#x27;</span>])  <span class="comment">#no</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">&#x27;bitbucket.org&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># user</span></span><br><span class="line"><span class="comment"># serveraliveinterval</span></span><br><span class="line"><span class="comment"># compression</span></span><br><span class="line"><span class="comment"># compressionlevel</span></span><br><span class="line"><span class="comment"># forwardx11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.options(<span class="string">&#x27;bitbucket.org&#x27;</span>))<span class="comment">#[&#x27;user&#x27;, &#x27;serveraliveinterval&#x27;, &#x27;compression&#x27;, &#x27;compressionlevel&#x27;, &#x27;forwardx11&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(config.items(<span class="string">&#x27;bitbucket.org&#x27;</span>))  <span class="comment">#[(&#x27;serveraliveinterval&#x27;, &#x27;45&#x27;), (&#x27;compression&#x27;, &#x27;yes&#x27;), (&#x27;compressionlevel&#x27;, &#x27;9&#x27;), (&#x27;forwardx11&#x27;, &#x27;yes&#x27;), (&#x27;user&#x27;, &#x27;hg&#x27;)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.get(<span class="string">&#x27;bitbucket.org&#x27;</span>,<span class="string">&#x27;compression&#x27;</span>))<span class="comment">#yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------删,改,增(config.write(open(&#x27;i.cfg&#x27;, &quot;w&quot;)))</span></span><br><span class="line"></span><br><span class="line">config.add_section(<span class="string">&#x27;yuan&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config.remove_section(<span class="string">&#x27;topsecret.server.com&#x27;</span>)</span><br><span class="line">config.remove_option(<span class="string">&#x27;bitbucket.org&#x27;</span>,<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config.<span class="built_in">set</span>(<span class="string">&#x27;bitbucket.org&#x27;</span>,<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&#x27;i.cfg&#x27;</span>, <span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="1-10-hashlib模块"><a href="#1-10-hashlib模块" class="headerlink" title="1.10 hashlib模块"></a>1.10 hashlib模块</h4><p>摘要算法：md5，sha256等。只能将明文变为密文，不是可逆操作。</p>
<p>密码操作将所有的明文都变成密文在进行比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line">m=hashlib.md5()<span class="comment"># m=hashlib.sha256()</span></span><br><span class="line"> </span><br><span class="line">m.update(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(m.hexdigest())  <span class="comment">#5d41402abc4b2a76b9719d911017c592</span></span><br><span class="line"> </span><br><span class="line">m.update(<span class="string">&#x27;alvin&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m.hexdigest())  <span class="comment">#92a7e713c30abbb0319fa07da2a5c4af</span></span><br><span class="line"> </span><br><span class="line">m2=hashlib.md5()</span><br><span class="line">m2.update(<span class="string">&#x27;helloalvin&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(m2.hexdigest()) <span class="comment">#92a7e713c30abbb0319fa07da2a5c4af</span></span><br></pre></td></tr></table></figure>

<p>hash</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ######## 256 ########</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">hash</span> = hashlib.sha256(<span class="string">&#x27;898oaFs09f&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">hash</span>.update(<span class="string">&#x27;alvin&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hash</span>.hexdigest())<span class="comment">#e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7</span></span><br></pre></td></tr></table></figure>

<p>不同对象的区分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_md5</span>():</span></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(<span class="built_in">str</span>(time.time()).encode(utf-<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">school</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">id</span> = create_md5() <span class="comment"># 通过id区分</span></span><br><span class="line">        <span class="comment">#通过pickle保存到文件</span></span><br></pre></td></tr></table></figure>

<h4 id="1-11-subprocess模块"><a href="#1-11-subprocess模块" class="headerlink" title="1.11 subprocess模块"></a>1.11 subprocess模块</h4><p>我们需要调用系统的命令的时候，最先考虑的os模块。用os.system()和os.popen()来进行操作。但是这两个命令过于简单，不能完成一些复杂的操作，如给运行的命令提供输入或者读取命令的输出，判断该命令的运行状态，管理多个命令的并行等等。这时subprocess中的Popen命令就能有效的完成我们需要的操作。</p>
<p>​      subprocess模块允许一个进程创建一个新的子进程，通过管道连接到子进程的stdin/stdout/stderr，获取子进程的返回值等操作。 </p>
<p>这个模块一个类：Popen。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#Popen它的构造函数如下：` `subprocess.Popen(args, bufsize``=``0``, executable``=``None``, stdin``=``None``, stdout``=``None``,stderr``=``None``, preexec_fn``=``None``, close_fds``=``False``, shell``=``False``,&lt;br&gt;     `</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(<span class="string">&#x27;dir&#x27;</span>,shell=<span class="literal">True</span>)  <span class="comment">#shell：命令解释器</span></span><br><span class="line"></span><br><span class="line">res = subprocess.Popen(<span class="string">&#x27;dir&#x27;</span>,shell=<span class="literal">True</span>)</span><br><span class="line">res.stdout.read().decode()   stdout--&gt;输出给管道</span><br><span class="line">管道中对象只能取一次</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">err = res.stderr.read()</span><br><span class="line">if err:</span><br><span class="line">msg = err</span><br><span class="line">else:</span><br><span class="line">msg = res.stdout.read()</span><br><span class="line">print(msg.decode(&#x27;utf-8&#x27;))</span><br><span class="line">if msg:</span><br><span class="line">self.send_bytes(msg)</span><br><span class="line">else:</span><br><span class="line">self.send_msg(&#x27;No return msg.&#x27;)</span><br></pre></td></tr></table></figure>



<p><strong>简单命令：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"> </span><br><span class="line">a=subprocess.Popen(<span class="string">&#x27;ls&#x27;</span>)<span class="comment">#  创建一个新的进程,与主进程不同步</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#x27;</span>,a)<span class="comment">#a是Popen的一个实例对象</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;subprocess.Popen object at 0x10185f860&gt;</span></span><br><span class="line"><span class="string">__init__.py</span></span><br><span class="line"><span class="string">__pycache__</span></span><br><span class="line"><span class="string">log.py</span></span><br><span class="line"><span class="string">main.py</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen(&#x27;ls -l&#x27;,shell=True)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen([&#x27;ls&#x27;,&#x27;-l&#x27;])</span></span><br></pre></td></tr></table></figure>

<p><strong>subprocess.PIPE</strong></p>
<p>在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数。表示与子进程通信的标准流。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen(&#x27;ls&#x27;)</span></span><br><span class="line">p=subprocess.Popen(<span class="string">&#x27;ls&#x27;</span>,stdout=subprocess.PIPE)<span class="comment">#结果跑哪去啦?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.stdout.read())<span class="comment">#这这呢:b&#x27;__pycache__\nhello.py\nok.py\nweb\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这是因为subprocess创建了子进程，结果本在子进程中，if 想要执行结果转到主进程中，就得需要一个管道，即 ： stdout=subprocess.PIPE</p>
<p><strong>subprocess.STDOUT</strong></p>
<p>创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。</p>
<p><strong>Popen的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Popen.poll() </span><br><span class="line">用于检查子进程是否已经结束。设置并返回returncode属性。</span><br><span class="line"></span><br><span class="line">Popen.wait() </span><br><span class="line">等待子进程结束。设置并返回returncode属性。</span><br><span class="line"></span><br><span class="line">Popen.communicate(input=None)</span><br><span class="line">与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</span><br><span class="line"></span><br><span class="line">Popen.send_signal(signal) </span><br><span class="line">向子进程发送信号。</span><br><span class="line"></span><br><span class="line">Popen.terminate()</span><br><span class="line">停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。</span><br><span class="line"></span><br><span class="line">Popen.kill()</span><br><span class="line">杀死子进程。</span><br><span class="line"></span><br><span class="line">Popen.stdin </span><br><span class="line">如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。</span><br><span class="line"></span><br><span class="line">Popen.stdout </span><br><span class="line">如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</span><br><span class="line"></span><br><span class="line">Popen.stderr </span><br><span class="line">如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</span><br><span class="line"></span><br><span class="line">Popen.pid </span><br><span class="line">获取子进程的进程ID。</span><br><span class="line"></span><br><span class="line">Popen.returncode </span><br><span class="line">获取进程的返回值。如果进程还没有结束，返回None。</span><br></pre></td></tr></table></figure>

<p><strong>supprocess模块的工具函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">supprocess模块提供了一些函数，方便我们用于创建进程来实现一些简单的功能。</span><br><span class="line"> </span><br><span class="line">subprocess.call(*popenargs, **kwargs)</span><br><span class="line">运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。如果子进程不需要进行交 互,就可以使用该函数来创建。</span><br><span class="line"> </span><br><span class="line">subprocess.check_call(*popenargs, **kwargs)</span><br><span class="line">与subprocess.call(*popenargs, **kwargs)功能一样，只是如果子进程返回的returncode不为<span class="number">0</span>的话，将触发CalledProcessError异常。在异常对象中，包 括进程的returncode信息。</span><br><span class="line"> </span><br><span class="line">check_output(*popenargs, **kwargs)</span><br><span class="line">与call()方法类似，以byte string的方式返回子进程的输出，如果子进程的返回值不是<span class="number">0</span>，它抛出CalledProcessError异常，这个异常中的returncode包含返回码，output属性包含已有的输出。</span><br><span class="line"> </span><br><span class="line">getstatusoutput(cmd)/getoutput(cmd)</span><br><span class="line">这两个函数仅仅在Unix下可用，它们在shell中执行指定的命令cmd，前者返回(status, output)，后者返回output。其中，这里的output包括子进程的stdout和stderr。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment"># subprocess.call(&#x27;ls&#x27;,shell=True)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># data=subprocess.call(&#x27;ls&#x27;,shell=True)</span></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment"># subprocess.check_call(&#x27;ls&#x27;,shell=True)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># data=subprocess.check_call(&#x27;ls&#x27;,shell=True)</span></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 两个函数区别:只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment"># subprocess.check_output(&#x27;ls&#x27;)#无结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data=subprocess.check_output(&#x27;ls&#x27;)</span></span><br><span class="line"><span class="comment"># print(data)  #b&#x27;hello.py\nok.py\nweb\n&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-12-struct-模块"><a href="#1-12-struct-模块" class="headerlink" title="1.12 struct 模块"></a>1.12 struct 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">l = struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="number">123</span>) <span class="comment">#将数字打包为4字节</span></span><br><span class="line">struct.unpack(<span class="string">&#x27;i&#x27;</span>,l) <span class="comment">#返回元组</span></span><br></pre></td></tr></table></figure>



<h4 id="1-13-partial模块"><a href="#1-13-partial模块" class="headerlink" title="1.13 partial模块"></a>1.13 partial模块</h4><p>为函数提供参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> partial</span><br><span class="line">func = partial(test,<span class="number">1</span>)</span><br><span class="line">func(<span class="number">3</span>)  <span class="comment">#4</span></span><br></pre></td></tr></table></figure>

<h4 id="1-14-optparse模块"><a href="#1-14-optparse模块" class="headerlink" title="1.14 optparse模块"></a>1.14 optparse模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line">x = optparse.OptionParser()</span><br><span class="line">x.add_option(<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;--s&#x27;</span>,dest=<span class="string">&#x27;server&#x27;</span>)</span><br><span class="line">x.add_option(<span class="string">&#x27;-P&#x27;</span>,<span class="string">&#x27;--port&#x27;</span>,dest=<span class="string">&#x27;port&#x27;</span>)</span><br><span class="line"></span><br><span class="line">options,args = x.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># options为形似字典的对象，储存绑定的参数</span></span><br><span class="line"><span class="comment"># args为列表，储存盈余的信息</span></span><br><span class="line"></span><br><span class="line">options.server <span class="comment">#返回server对应的参数</span></span><br></pre></td></tr></table></figure>

<h4 id="1-15-uuid"><a href="#1-15-uuid" class="headerlink" title="1.15 uuid"></a>1.15 uuid</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid </span><br><span class="line">uuid.uuid4()  生成随机数</span><br></pre></td></tr></table></figure>

<h4 id="1-16-concurrent"><a href="#1-16-concurrent" class="headerlink" title="1.16 concurrent"></a>1.16 concurrent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExector</span><br><span class="line">import request</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line">		response = request.get(url)	</span><br><span class="line">		print(response)</span><br><span class="line">		return response</span><br><span class="line"></span><br><span class="line">def func(future,*args,**kwargs):</span><br><span class="line">		future 默认为task的返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExector(5)</span><br><span class="line">v = pool.submit(task,url)</span><br><span class="line">v.add_done_callback(func,args)</span><br><span class="line"></span><br><span class="line">concurrent有参数xx</span><br></pre></td></tr></table></figure>

<h4 id="1-XX-iter的参数"><a href="#1-XX-iter的参数" class="headerlink" title="1.XX iter的参数"></a>1.XX iter的参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">12</span>,<span class="number">41</span>,<span class="number">25</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">return</span> l.pop()</span><br><span class="line"></span><br><span class="line">iiii = <span class="built_in">iter</span>(test,<span class="number">41</span>)  <span class="number">41</span>为终止参数</span><br><span class="line">iiii.__next__()</span><br><span class="line">iiii.__next__()</span><br><span class="line">iiii.__next__() 返回<span class="number">41</span>时报错iterstop</span><br></pre></td></tr></table></figure>



<h2 id="六、面向对象"><a href="#六、面向对象" class="headerlink" title="六、面向对象"></a>六、面向对象</h2><p>面向对象<a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaifeng/articles/6182264.html">https://www.cnblogs.com/linhaifeng/articles/6182264.html</a></p>
<p><code>&lt;classname&gt;.__dict__</code> 返回属性字典</p>
<p>函数的输入输出要分开，类中函数只包含逻辑</p>
<p><strong>类中变量调用</strong></p>
<ol>
<li>点调用：在实例属性–》类属性中寻找</li>
<li>非点调用：在类外寻找</li>
</ol>
<p><strong>静态属性</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property将函数变为静态属性，调用时直接点调用静态属性即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> xx</span><br><span class="line"></span><br><span class="line">a = yy()</span><br><span class="line"><span class="built_in">print</span>(a.test)</span><br></pre></td></tr></table></figure>

<p><strong>类方法</strong></p>
<p>与类绑定，不与实例绑定</p>
<p>不需要实例化类，可以直接使用</p>
<p>类方法不能调用实例属性，即不能使用self.xxx</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">cls</span>):</span> <span class="comment">## cls为类名</span></span><br><span class="line">        <span class="keyword">return</span> cls.tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(yy.test())</span><br></pre></td></tr></table></figure>

<p><strong>静态方法</strong></p>
<p>不与类绑定，也不与实例绑定，只是类的工具包</p>
<p>实例无法调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">y.a</span><br></pre></td></tr></table></figure>

<p><strong>组合</strong></p>
<p>软件重用的重要方式除了继承之外还有另外一种方式，即：组合</p>
<p>组合指的是，在一个类中以另外一个类的对象作为数据属性，称为<strong>类的组合</strong></p>
<p>类与类之间的关联</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,addr</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.addr=addr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zhao_sheng</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 正在招生&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,price,period,school</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.price=price</span><br><span class="line">        self.period=period</span><br><span class="line">        self.school=school</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1=School(<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">s2=School(<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;南京&#x27;</span>)</span><br><span class="line">s3=School(<span class="string">&#x27;oldboy&#x27;</span>,<span class="string">&#x27;东京&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c1=Course(&#x27;linux&#x27;,10,&#x27;1h&#x27;,&#x27;oldboy 北京&#x27;)</span></span><br><span class="line">c1=Course(<span class="string">&#x27;linux&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;1h&#x27;</span>,s1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1.__dict__)</span><br><span class="line"><span class="built_in">print</span>(c1.school.name)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>

<h3 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1. 三大特性"></a>1. 三大特性</h3><p>继承、封装、多态</p>
<h4 id="1-1继承"><a href="#1-1继承" class="headerlink" title="1.1继承"></a>1.1继承</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/7340153.html#_label4">继承与派生</a></p>
<p>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好。</p>
<p>当类之间有很多相通的功能，提取这些共同的功能做成基类，用继承比较好。</p>
<p><strong>继承有两种含义</strong></p>
<p>含义一：继承基类的方法，并且做出自己的改变或拓展（代码重用）  —》有害，代码之间存在耦合<br>含义二(接口继承)：声明某个子类兼容于某基类，定义一个接口类（父类中定义函数，但不实现，由子类实现，import abs, @abc.abstractmethod），子类继承接口类，并在实现接口中定义的方法</p>
<p>在python中根本就没有一个叫做interface的关键字，如果非要去模仿接口的概念<br>可以借助第三方模块：<a target="_blank" rel="noopener" href="http://pypi.python.org/pypi/zope.interface">http://pypi.python.org/pypi/zope.interface</a></p>
<p><strong>抽象类</strong></p>
<p>与java一样，python也有抽象类的概念但是同样需要借助模块实现，<strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p>
<p><strong>抽象类与接口</strong></p>
<p><em>抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。</em></p>
<p>抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计</p>
<p><strong>接口继承</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">All_file</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment">###接口类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span>(<span class="params">All_file</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;disk read&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;disk write&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cdrom</span>(<span class="params">All_file</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cdrom read&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cdrom write&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>(<span class="params">All_file</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;mem read&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;mem write&#x27;</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">m1=Mem()</span><br><span class="line">m1.read()</span><br><span class="line">m1.write()</span><br></pre></td></tr></table></figure>

<p><strong>归一化设计</strong></p>
<p>接口继承实质上要求“作出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理是吸纳了特定接口的所有对象”—这在程序设计上叫做归一化。</p>
<p><strong>派生</strong></p>
<p>当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。</p>
<p>** 继承顺序**</p>
<p>在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如A(B,C,D)</p>
<p>如果继承关系为非菱形结构，则会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p>
<p>如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：深度优先和广度优先</p>
<p><img src="./image/5.png"></p>
<p><img src="./image/6.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">C</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from E&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">D,E</span>):</span></span><br><span class="line">    <span class="comment"># def test(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;from F&#x27;)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">f1=F()</span><br><span class="line">f1.test()</span><br><span class="line"><span class="built_in">print</span>(F.__mro__) <span class="comment">#只有新式才有这个属性可以查看线性列表，经典类没有这个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A</span></span><br><span class="line"><span class="comment">#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C</span></span><br><span class="line"><span class="comment">#python3中统一都是新式类</span></span><br><span class="line"><span class="comment">#pyhon2中才分新式类与经典类</span></span><br></pre></td></tr></table></figure>

<p> <strong>继承原理（python如何实现的继承）</strong></p>
<p>python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; F.mro() #等同于F.__mro__</span><br><span class="line">[&lt;class &#x27;__main__.F&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure>

<p>为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。<br>而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:<br>1.子类会先于父类被检查<br>2.多个父类会根据它们在列表中的顺序被检查<br>3.如果对下一个类存在两个合法的选择,选择第一个父类</p>
<h4 id="1-2-子类中调用父类方法"><a href="#1-2-子类中调用父类方法" class="headerlink" title="1.2 子类中调用父类方法"></a>1.2 子类中调用父类方法</h4><p>需要先执行_<em>init</em>_()<br><strong>方法一</strong>：指名道姓，即父类名.父类方法()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span> <span class="comment">#定义交通工具类</span></span><br><span class="line">     Country=<span class="string">&#x27;China&#x27;</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,speed,load,power</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.speed=speed</span><br><span class="line">         self.load=load</span><br><span class="line">         self.power=power</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;开动啦...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subway</span>(<span class="params">Vehicle</span>):</span> <span class="comment">#地铁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,speed,load,power,line</span>):</span></span><br><span class="line">        Vehicle.__init__(self,name,speed,load,power)</span><br><span class="line">        self.line=line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;地铁%s号线欢迎您&#x27;</span> %self.line)</span><br><span class="line">        Vehicle.run(self)</span><br><span class="line"></span><br><span class="line">line13=Subway(<span class="string">&#x27;中国地铁&#x27;</span>,<span class="string">&#x27;180m/s&#x27;</span>,<span class="string">&#x27;1000人/箱&#x27;</span>,<span class="string">&#x27;电&#x27;</span>,<span class="number">13</span>)</span><br><span class="line">line13.run()</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：super()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span> <span class="comment">#定义交通工具类</span></span><br><span class="line">     Country=<span class="string">&#x27;China&#x27;</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,speed,load,power</span>):</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.speed=speed</span><br><span class="line">         self.load=load</span><br><span class="line">         self.power=power</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;开动啦...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subway</span>(<span class="params">Vehicle</span>):</span> <span class="comment">#地铁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,speed,load,power,line</span>):</span></span><br><span class="line">        <span class="comment">#super(Subway,self) 就相当于实例本身 在python3中super()等同于super(Subway,self)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,speed,load,power)</span><br><span class="line">        self.line=line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;地铁%s号线欢迎您&#x27;</span> %self.line)</span><br><span class="line">        <span class="built_in">super</span>(Subway,self).run()</span><br><span class="line"></span><br><span class="line">line13=Subway(<span class="string">&#x27;中国地铁&#x27;</span>,<span class="string">&#x27;180m/s&#x27;</span>,<span class="string">&#x27;1000人/箱&#x27;</span>,<span class="string">&#x27;电&#x27;</span>,<span class="number">13</span>)</span><br><span class="line">line13.run()</span><br></pre></td></tr></table></figure>

<p><strong>二者使用哪一种都可以，但最好不要混合使用</strong> </p>
<p>即使没有直接继承关系，super仍然会按照mro继续往后查找<br>指名道姓与super()的区别</p>
<h3 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h3><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/7340687.html"><strong>http://www.cnblogs.com/linhaifeng/articles/7340687.html</strong></a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p>
<p>比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同</p>
<h3 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h3><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/7340801.html">http://www.cnblogs.com/linhaifeng/articles/7340801.html</a></strong></p>
<h4 id="x-python-OOP的常用术语"><a href="#x-python-OOP的常用术语" class="headerlink" title="x.python OOP的常用术语"></a>x.python OOP的常用术语</h4><p><strong>抽象/实现</strong></p>
<p>抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。</p>
<p>对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 </p>
<p><strong>封装/接口</strong></p>
<p>封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。</p>
<p>注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来”</p>
<p><strong>真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明</strong></p>
<p><strong>（注意：对外透明</strong>的意思是<strong>，</strong>外部调用者可以顺利的得到自己想要的任何功能，<strong>完全意识不到内部细节的存在）</strong></p>
<p><strong>合成</strong></p>
<p>合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。</p>
<p><strong>派生/继承/继承结构</strong></p>
<p>派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。<br>继承描述了子类属性从祖先类继承这样一种方式<br>继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。</p>
<p><strong>泛化/特化</strong></p>
<p>基于继承<br>泛化表示所有子类与其父类及祖先类有一样的特点。<br>特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。</p>
<p><strong>多态与多态性</strong></p>
<p>多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气</p>
<p>多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。</p>
<p>冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样</p>
<p><strong>自省/反射</strong></p>
<p>自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像__dict__,__name__及__doc__<br>hasattr()   getattr()</p>
<h3 id="1-4-面向对象进阶"><a href="#1-4-面向对象进阶" class="headerlink" title="1.4 面向对象进阶"></a>1.4 面向对象进阶</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaifeng/articles/6204014.html">https://www.cnblogs.com/linhaifeng/articles/6204014.html</a></p>
<h4 id="1-4-1动态导入模块"><a href="#1-4-1动态导入模块" class="headerlink" title="1.4.1动态导入模块"></a>1.4.1动态导入模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module_t = <span class="built_in">__import__</span>(m1.t)  <span class="comment">## 无论通过点调用多少层，最后导入的实际上是m1</span></span><br><span class="line">module_t等价于 m1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">m = importlib.import_module(m1.t)</span><br><span class="line">m等价于m1.t</span><br></pre></td></tr></table></figure>

<p>导入包时，会自动执行<code>__init__.py</code>文件</p>
<h4 id="1-4-2-双下划线开头的attr方法"><a href="#1-4-2-双下划线开头的attr方法" class="headerlink" title="1.4.2 双下划线开头的attr方法"></a>1.4.2 双下划线开头的attr方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    x=<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,y</span>):</span></span><br><span class="line">        self.y=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt; from getattr:你找的属性不存在&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt; from setattr&#x27;</span>)</span><br><span class="line">        <span class="comment"># self.key=value #这就无限递归了,你好好想想</span></span><br><span class="line">        <span class="comment"># self.__dict__[key]=value #应该使用它</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt; from delattr&#x27;</span>)</span><br><span class="line">        <span class="comment"># del self.item #无限递归了</span></span><br><span class="line">        self.__dict__.pop(item)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__setattr__添加/修改属性会触发它的执行</span></span><br><span class="line">f1=Foo(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(f1.__dict__) <span class="comment"># 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值</span></span><br><span class="line">f1.z=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(f1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__delattr__删除属性的时候会触发</span></span><br><span class="line">f1.__dict__[<span class="string">&#x27;a&#x27;</span>]=<span class="number">3</span><span class="comment">#我们可以直接修改属性字典,来完成添加/修改属性的操作</span></span><br><span class="line"><span class="keyword">del</span> f1.a</span><br><span class="line"><span class="built_in">print</span>(f1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__getattr__只有在使用点调用属性且属性不存在的时候才会触发</span></span><br><span class="line">f1.xxxxxx</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-getattribute"><a href="#1-4-3-getattribute" class="headerlink" title="1.4.3 __getattribute__"></a>1.4.3 <code>__getattribute__</code></h4><p>无论属性是否存在，都会触发<code>__getattribute__</code><br>当抛出AttributeError异常时，触发<code>__getattr__</code></p>
<h4 id="1-4-4-授权"><a href="#1-4-4-授权" class="headerlink" title="1.4.4 授权"></a>1.4.4 授权</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filename,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span></span>):</span></span><br><span class="line">        self.file=<span class="built_in">open</span>(filename,mode,encoding=encoding)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self,line</span>):</span></span><br><span class="line">        t=time.strftime(<span class="string">&#x27;%Y-%m-%d %T&#x27;</span>)</span><br><span class="line">        self.file.write(<span class="string">&#x27;%s %s&#x27;</span> %(t,line))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.file,item)</span><br><span class="line"></span><br><span class="line">f1=FileHandle(<span class="string">&#x27;b.txt&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">f1.write(<span class="string">&#x27;你好啊&#x27;</span>)</span><br><span class="line">f1.seek(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(f1.read())</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-isinstance-obj-cls-和issubclass-sub-super"><a href="#1-4-5-isinstance-obj-cls-和issubclass-sub-super" class="headerlink" title="1.4.5 isinstance(obj,cls)和issubclass(sub,super)"></a>1.4.5 isinstance(obj,cls)和issubclass(sub,super)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">isinstance</span>(obj, Foo) <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">Foo</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">issubclass</span>(Bar, Foo) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>



<h4 id="1-4-6-setitem-getitem-delitem"><a href="#1-4-6-setitem-getitem-delitem" class="headerlink" title="1.4.6 __setitem__,__getitem__,__delitem__"></a>1.4.6 <code>__setitem__,__getitem__,__delitem__</code></h4><p>字典（中括号）方式触发的是item操作</p>
<p>点操作触发的是attr操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.__dict__[item])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.__dict__[key]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del obj[key]时,我执行&#x27;</span>)</span><br><span class="line">        self.__dict__.pop(key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del obj.key时,我执行&#x27;</span>)</span><br><span class="line">        self.__dict__.pop(item)</span><br><span class="line"></span><br><span class="line">f1=Foo(<span class="string">&#x27;sb&#x27;</span>)</span><br><span class="line">f1[<span class="string">&#x27;age&#x27;</span>]=<span class="number">18</span>    <span class="comment">##__setitem__</span></span><br><span class="line">f1[<span class="string">&#x27;age1&#x27;</span>]=<span class="number">19</span>	</span><br><span class="line"><span class="keyword">del</span> f1.age1		</span><br><span class="line"><span class="keyword">del</span> f1[<span class="string">&#x27;age&#x27;</span>]		</span><br><span class="line">f1[<span class="string">&#x27;name&#x27;</span>]=<span class="string">&#x27;alex&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(f1.__dict__)</span><br></pre></td></tr></table></figure>

<h4 id="1-4-7-str-repr-format"><a href="#1-4-7-str-repr-format" class="headerlink" title="1.4.7 __str__,__repr__,__format__"></a>1.4.7 <code>__str__,__repr__,__format__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">&#x27;Linhaifeng&#x27;</span></span><br><span class="line">format_dict=&#123;</span><br><span class="line">    <span class="string">&#x27;nat&#x27;</span>:<span class="string">&#x27;&#123;obj.name&#125;-&#123;obj.addr&#125;-&#123;obj.type&#125;&#x27;</span>,<span class="comment">#学校名-学校地址-学校类型</span></span><br><span class="line">    <span class="string">&#x27;tna&#x27;</span>:<span class="string">&#x27;&#123;obj.type&#125;:&#123;obj.name&#125;:&#123;obj.addr&#125;&#x27;</span>,<span class="comment">#学校类型:学校名:学校地址</span></span><br><span class="line">    <span class="string">&#x27;tan&#x27;</span>:<span class="string">&#x27;&#123;obj.type&#125;/&#123;obj.addr&#125;/&#123;obj.name&#125;&#x27;</span>,<span class="comment">#学校类型/学校地址/学校名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,addr,<span class="built_in">type</span></span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.addr=addr</span><br><span class="line">        self.<span class="built_in">type</span>=<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;School(%s,%s)&#x27;</span> %(self.name,self.addr)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(%s,%s)&#x27;</span> %(self.name,self.addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self, format_spec</span>):</span></span><br><span class="line">        <span class="comment"># if format_spec</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> format_spec <span class="keyword">or</span> format_spec <span class="keyword">not</span> <span class="keyword">in</span> format_dict:</span><br><span class="line">            format_spec=<span class="string">&#x27;nat&#x27;</span></span><br><span class="line">        fmt=format_dict[format_spec]</span><br><span class="line">        <span class="keyword">return</span> fmt.<span class="built_in">format</span>(obj=self)</span><br><span class="line"></span><br><span class="line">s1=School(<span class="string">&#x27;oldboy1&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;私立&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;from repr: &#x27;</span>,<span class="built_in">repr</span>(s1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;from str: &#x27;</span>,<span class="built_in">str</span>(s1))</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">str函数或者print函数---&gt;obj.__str__()</span></span><br><span class="line"><span class="string">repr或者交互式解释器---&gt;obj.__repr__()</span></span><br><span class="line"><span class="string">如果__str__没有被定义,那么就会使用__repr__来代替输出</span></span><br><span class="line"><span class="string">注意:这俩方法的返回值必须是字符串,否则抛出异常</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(s1,<span class="string">&#x27;nat&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(s1,<span class="string">&#x27;tna&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(s1,<span class="string">&#x27;tan&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(s1,<span class="string">&#x27;asfdasdffd&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>自定义format</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">date_dic=&#123;</span><br><span class="line">    <span class="string">&#x27;ymd&#x27;</span>:<span class="string">&#x27;&#123;0.year&#125;:&#123;0.month&#125;:&#123;0.day&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dmy&#x27;</span>:<span class="string">&#x27;&#123;0.day&#125;/&#123;0.month&#125;/&#123;0.year&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mdy&#x27;</span>:<span class="string">&#x27;&#123;0.month&#125;-&#123;0.day&#125;-&#123;0.year&#125;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,year,month,day</span>):</span></span><br><span class="line">        self.year=year</span><br><span class="line">        self.month=month</span><br><span class="line">        self.day=day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self, format_spec</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> format_spec <span class="keyword">or</span> format_spec <span class="keyword">not</span> <span class="keyword">in</span> date_dic:</span><br><span class="line">            format_spec=<span class="string">&#x27;ymd&#x27;</span></span><br><span class="line">        fmt=date_dic[format_spec]</span><br><span class="line">        <span class="keyword">return</span> fmt.<span class="built_in">format</span>(self)</span><br><span class="line"></span><br><span class="line">d1=Date(<span class="number">2016</span>,<span class="number">12</span>,<span class="number">29</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(d1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:mdy&#125;&#x27;</span>.<span class="built_in">format</span>(d1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-8-slot"><a href="#1-4-8-slot" class="headerlink" title="1.4.8 __slot__"></a>1.4.8 <code>__slot__</code></h4><p>类的数据属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1.__slots__是什么:是一个类变量,变量值可以是列表,元组,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)</span></span><br><span class="line"><span class="string">2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的)</span></span><br><span class="line"><span class="string">3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__</span></span><br><span class="line"><span class="string">当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个</span></span><br><span class="line"><span class="string">字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给</span></span><br><span class="line"><span class="string">实例添加新的属性了,只能使用在__slots__中定义的那些属性名。</span></span><br><span class="line"><span class="string">4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该</span></span><br><span class="line"><span class="string">只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。</span></span><br><span class="line"><span class="string">关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。           更多的是用来作为一个内存优化工具。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __slots__=<span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.x=<span class="number">1</span></span><br><span class="line">f1.y=<span class="number">2</span><span class="comment">#报错</span></span><br><span class="line"><span class="built_in">print</span>(f1.__slots__) <span class="comment">#f1不再有__dict__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    __slots__=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">n=Bar()</span><br><span class="line">n.x,n.y=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">n.z=<span class="number">3</span><span class="comment">#报错</span></span><br><span class="line"></span><br><span class="line">__slots__使用</span><br></pre></td></tr></table></figure>

<h4 id="1-4-9-doc"><a href="#1-4-9-doc" class="headerlink" title="1.4.9 __doc__"></a>1.4.9 <code>__doc__</code></h4><p>无法继承给子类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="string">&#x27;我是描述信息&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">Foo</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(Bar.__doc__) <span class="comment">#该属性无法继承给子类</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-10-module-和-class"><a href="#1-4-10-module-和-class" class="headerlink" title="1.4.10 __module__和__class__"></a>1.4.10 <code>__module__和__class__</code></h4><p><code>__module__ </code>表示当前操作的对象在那个模块</p>
<p><code>__class__</code>  表示当前操作的对象的类是什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.aa <span class="keyword">import</span> C</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line"><span class="built_in">print</span> obj.__module__  <span class="comment"># 输出 lib.aa，即：输出模块</span></span><br><span class="line"><span class="built_in">print</span> obj.__class__      <span class="comment"># 输出 lib.aa.C，即：输出类</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-11-del"><a href="#1-4-11-del" class="headerlink" title="1.4.11 __del__"></a>1.4.11 <code>__del__</code></h4><p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义<code>__del__</code>,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了<code>__del__</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行我啦&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line"><span class="keyword">del</span> f1</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">执行我啦</span><br><span class="line">-------&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-12-call"><a href="#1-4-12-call" class="headerlink" title="1.4.12 __call__"></a>1.4.12 <code>__call__</code></h4><p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <code>__call__ </code>方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__call__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = Foo() <span class="comment"># 执行 __init__</span></span><br><span class="line">obj()       <span class="comment"># 执行 __call__</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-13-迭代器协议"><a href="#1-4-13-迭代器协议" class="headerlink" title="1.4.13 迭代器协议"></a>1.4.13 迭代器协议</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,start,stop</span>):</span></span><br><span class="line">        self.num=start</span><br><span class="line">        self.stop=stop</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.num &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        n=self.num</span><br><span class="line">        self.num+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">f=Foo(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable,Iterator</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(f,Iterator))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Foo(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>斐波那契数列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._a=<span class="number">0</span></span><br><span class="line">        self._b=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._a,self._b=self._b,self._a + self._b</span><br><span class="line">        <span class="keyword">return</span> self._a</span><br><span class="line"></span><br><span class="line">f1=Fib()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f1.__next__())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f1))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s &#x27;</span> %i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-14-描述符（-get-set-delete-）"><a href="#1-4-14-描述符（-get-set-delete-）" class="headerlink" title="1.4.14 描述符（__get__,__set__,__delete__）"></a>1.4.14 描述符（<code>__get__,__set__,__delete__</code>）</h4><p>1 描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了<code>__get__(),__set__(),__delete__()</code>中的一个,这也被称为描述符协议<br><code>__get__()</code>:调用一个属性时,触发<br><code>__set__()</code>:为一个属性赋值时,触发<br><code>__delete__()</code>:采用del删除属性时,触发</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="comment">#在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">定义一个描述符</span><br></pre></td></tr></table></figure>

<p>2 描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;触发get&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;触发set&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;触发delete&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.name=<span class="string">&#x27;egon&#x27;</span></span><br><span class="line">f1.name</span><br><span class="line"><span class="keyword">del</span> f1.name</span><br><span class="line"><span class="comment">#疑问:何时,何地,会触发这三个方法的执行</span></span><br><span class="line"></span><br><span class="line">引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行</span><br></pre></td></tr></table></figure>

<p>描述符的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#描述符Str</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Str调用&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Str设置...&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Str删除...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Int</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Int调用&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Int设置...&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Int删除...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    name=Str()</span><br><span class="line">    age=Int()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span> <span class="comment">#name被Str类代理,age被Int类代理,</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"><span class="comment">#何地？：定义成另外一个类的类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#何时？：且看下列演示</span></span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">&#x27;alex&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Str的使用</span></span><br><span class="line">p1.name</span><br><span class="line">p1.name=<span class="string">&#x27;egon&#x27;</span></span><br><span class="line"><span class="keyword">del</span> p1.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Int的使用</span></span><br><span class="line">p1.age</span><br><span class="line">p1.age=<span class="number">18</span></span><br><span class="line"><span class="keyword">del</span> p1.age</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们来瞅瞅到底发生了什么</span></span><br><span class="line"><span class="built_in">print</span>(p1.__dict__)</span><br><span class="line"><span class="built_in">print</span>(People.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#补充</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p1) == People) <span class="comment">#type(obj)其实是查看obj是由哪个类实例化来的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p1).__dict__ == People.__dict__)</span><br></pre></td></tr></table></figure>

<p>3 描述符分两种<br>一 数据描述符:至少实现了__get__()和__set__()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 class Foo:</span><br><span class="line">2     def __set__(self, instance, value):</span><br><span class="line">3         print(&#x27;set&#x27;)</span><br><span class="line">4     def __get__(self, instance, owner):</span><br><span class="line">5         print(&#x27;get&#x27;)</span><br></pre></td></tr></table></figure>

<p>二 非数据描述符:没有实现__set__()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 class Foo:</span><br><span class="line">2     def __get__(self, instance, owner):</span><br><span class="line">3         print(&#x27;get&#x27;)</span><br></pre></td></tr></table></figure>

<p>4 注意事项:<br>一 描述符本身应该定义成新式类,被代理的类也应该是新式类<br>二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中<br>三 要严格遵循该优先级,优先级由高到底分别是<br>1.类属性<br>2.数据描述符<br>3.实例属性<br>4.非数据描述符<br>5.找不到的属性触发__getattr__()</p>
<p><strong>类属性&gt;数据描述符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#描述符Str</span><br><span class="line">class Str:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#x27;Str调用&#x27;)</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#x27;Str设置...&#x27;)</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        print(&#x27;Str删除...&#x27;)</span><br><span class="line"></span><br><span class="line">class People:</span><br><span class="line">    name=Str()</span><br><span class="line">    def __init__(self,name,age): #name被Str类代理,age被Int类代理,</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典</span><br><span class="line"></span><br><span class="line">#那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错</span><br><span class="line">People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__()</span><br><span class="line"></span><br><span class="line">People.name=&#x27;egon&#x27; #那赋值呢,我去,并没有触发__set__()</span><br><span class="line">del People.name #赶紧试试del,我去,也没有触发__delete__()</span><br><span class="line">#结论:描述符对类没有作用--------&gt;傻逼到家的结论</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级</span><br><span class="line">People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__()</span><br><span class="line"></span><br><span class="line">People.name=&#x27;egon&#x27; #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__()</span><br><span class="line">del People.name #同上</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>数据描述符&gt;实例属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#描述符Str</span><br><span class="line">class Str:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#x27;Str调用&#x27;)</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#x27;Str设置...&#x27;)</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        print(&#x27;Str删除...&#x27;)</span><br><span class="line"></span><br><span class="line">class People:</span><br><span class="line">    name=Str()</span><br><span class="line">    def __init__(self,name,age): #name被Str类代理,age被Int类代理,</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1=People(&#x27;egon&#x27;,18)</span><br><span class="line"></span><br><span class="line">#如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性</span><br><span class="line">p1.name=&#x27;egonnnnnn&#x27;</span><br><span class="line">p1.name</span><br><span class="line">print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看/赋值/删除都是跟描述符有关,与实例无关了</span><br><span class="line">del p1.name</span><br></pre></td></tr></table></figure>
<p>**实例属性&gt;非数据描述符 **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&#x27;我胡汉三又回来了&#x27;)</span><br><span class="line">f1=Foo()</span><br><span class="line">f1.func() #调用类的方法,也可以说是调用非数据描述符</span><br><span class="line">#函数是一个非数据描述符对象(一切皆对象么)</span><br><span class="line">print(dir(Foo.func))</span><br><span class="line">print(hasattr(Foo.func,&#x27;__set__&#x27;))</span><br><span class="line">print(hasattr(Foo.func,&#x27;__get__&#x27;))</span><br><span class="line">print(hasattr(Foo.func,&#x27;__delete__&#x27;))</span><br><span class="line">#有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了</span><br><span class="line">#笨蛋哥,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么</span><br><span class="line">#函数就是一个由非描述符类实例化得到的对象</span><br><span class="line">#没错，字符串也一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1.func=&#x27;这是实例属性啊&#x27;</span><br><span class="line">print(f1.func)</span><br><span class="line"></span><br><span class="line">del f1.func #删掉了非数据</span><br><span class="line">f1.func()</span><br></pre></td></tr></table></figure>

<p><strong>再次验证：实例属性&gt;非数据描述符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#x27;set&#x27;)</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#x27;get&#x27;)</span><br><span class="line">class Room:</span><br><span class="line">    name=Foo()</span><br><span class="line">    def __init__(self,name,width,length):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#name是一个数据描述符,因为name=Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级</span><br><span class="line">#对实例的属性操作,触发的都是描述符的</span><br><span class="line">r1=Room(&#x27;厕所&#x27;,1,1)</span><br><span class="line">r1.name</span><br><span class="line">r1.name=&#x27;厨房&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#x27;get&#x27;)</span><br><span class="line">class Room:</span><br><span class="line">    name=Foo()</span><br><span class="line">    def __init__(self,name,width,length):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#name是一个非数据描述符,因为name=Foo()而Foo没有实现set方法,因而比实例属性有更低的优先级</span><br><span class="line">#对实例的属性操作,触发的都是实例自己的</span><br><span class="line">r1=Room(&#x27;厕所&#x27;,1,1)</span><br><span class="line">r1.name</span><br><span class="line">r1.name=&#x27;厨房&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>非数据描述符&gt;找不到</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&#x27;我胡汉三又回来了&#x27;)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        print(&#x27;找不到了当然是来找我啦&#x27;,item)</span><br><span class="line">f1=Foo()</span><br><span class="line"></span><br><span class="line">f1.xxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>描述符的使用(类型检查)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,expected_type</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.expected_type=expected_type</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get---&gt;&#x27;</span>,instance,owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set---&gt;&#x27;</span>,instance,value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected %s&#x27;</span> %<span class="built_in">str</span>(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;delete---&gt;&#x27;</span>,instance)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    name=Typed(<span class="string">&#x27;name&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line">    age=Typed(<span class="string">&#x27;name&#x27;</span>,<span class="built_in">int</span>)</span><br><span class="line">    salary=Typed(<span class="string">&#x27;name&#x27;</span>,<span class="built_in">float</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,salary</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="number">123</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br><span class="line">p1=People(<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="number">3333.3</span>)</span><br><span class="line">p1=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="number">3333</span>)</span><br><span class="line"></span><br><span class="line">大刀阔斧</span><br></pre></td></tr></table></figure>

<p>描述符+类装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,expected_type</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.expected_type=expected_type</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get---&gt;&#x27;</span>,instance,owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set---&gt;&#x27;</span>,instance,value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected %s&#x27;</span> %<span class="built_in">str</span>(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;delete---&gt;&#x27;</span>,instance)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类的装饰器开始运行啦------&gt;&#x27;</span>,kwargs)</span><br><span class="line">        <span class="keyword">for</span> name,expected_type <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(cls,name,Typed(name,expected_type))</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"><span class="meta">@typeassert(<span class="params">name=<span class="built_in">str</span>,age=<span class="built_in">int</span>,salary=<span class="built_in">float</span></span>) </span><span class="comment">#有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,salary</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(People.__dict__)</span><br><span class="line">p1=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br><span class="line"></span><br><span class="line">刀光剑影</span><br></pre></td></tr></table></figure>

<p>property底层魔法的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        self.func=func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是我们自己定制的静态属性,r1.area实际是要执行r1.area()&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self.func(instance) <span class="comment">#此时你应该明白,到底是谁在为你做自动传递self的事情</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,width,length</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Lazyproperty </span><span class="comment">#area=Lazyproperty(area) 相当于定义了一个类属性,即描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line">r1=Room(<span class="string">&#x27;alex&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r1.area)</span><br><span class="line"></span><br><span class="line">自己做一个@<span class="built_in">property</span></span><br></pre></td></tr></table></figure>

<p>延迟计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        self.func=func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是我们自己定制的静态属性,r1.area实际是要执行r1.area()&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---&gt;&#x27;</span>)</span><br><span class="line">            value=self.func(instance)</span><br><span class="line">            <span class="built_in">setattr</span>(instance,self.func.__name__,value) <span class="comment">#计算一次就缓存到实例的属性字典中</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,width,length</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Lazyproperty </span><span class="comment">#area=Lazyproperty(area) 相当于&#x27;定义了一个类属性,即描述符&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line">r1=Room(<span class="string">&#x27;alex&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r1.area) <span class="comment">#先从自己的属性字典找,没有再去类的中找,然后出发了area的__get__方法</span></span><br><span class="line"><span class="built_in">print</span>(r1.area) <span class="comment">#先从自己的属性字典找,找到了,是上次计算的结果,这样就不用每执行一次都去计算</span></span><br><span class="line"></span><br><span class="line">实现延迟计算功能</span><br></pre></td></tr></table></figure>



<h4 id="1-4-15-enter-exit"><a href="#1-4-15-enter-exit" class="headerlink" title="1.4.15 __enter__/__exit__"></a>1.4.15 <code>__enter__/__exit__</code></h4><p>我们知道在操作文件对象的时候可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 with open(&#x27;a.txt&#x27;) as f:</span><br><span class="line">2 　　&#x27;代码块&#x27;</span><br></pre></td></tr></table></figure>

<p>上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明<code>__enter__</code>和<code>__exit__</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&#x27;</span>)</span><br><span class="line">        <span class="comment"># return self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;with中代码块执行完毕时执行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">&#x27;a.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=====&gt;执行代码块&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(f,f.name)</span></span><br><span class="line"></span><br><span class="line">上下文管理协议</span><br></pre></td></tr></table></figure>

<p><code>__exit__()</code>中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;with中代码块执行完毕时执行我啊&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(exc_type)</span><br><span class="line">        <span class="built_in">print</span>(exc_val)</span><br><span class="line">        <span class="built_in">print</span>(exc_tb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">&#x27;a.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=====&gt;执行代码块&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;***着火啦,救火啊***&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0&#x27;</span>*<span class="number">100</span>) <span class="comment">#-------------------------------&gt;不会执行</span></span><br></pre></td></tr></table></figure>

<p>如果<code>__exit__()</code>返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;with中代码块执行完毕时执行我啊&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(exc_type)</span><br><span class="line">        <span class="built_in">print</span>(exc_val)</span><br><span class="line">        <span class="built_in">print</span>(exc_tb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">&#x27;a.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=====&gt;执行代码块&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;***着火啦,救火啊***&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0&#x27;</span>*<span class="number">100</span>) <span class="comment">#-------------------------------&gt;会执行</span></span><br></pre></td></tr></table></figure>

<p>模拟open</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filepath,mode=<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span></span>):</span></span><br><span class="line">        self.filepath=filepath</span><br><span class="line">        self.mode=mode</span><br><span class="line">        self.encoding=encoding</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># print(&#x27;enter&#x27;)</span></span><br><span class="line">        self.f=<span class="built_in">open</span>(self.filepath,mode=self.mode,encoding=self.encoding)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="comment"># print(&#x27;exit&#x27;)</span></span><br><span class="line">        self.f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.f,item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br><span class="line">    f.write(<span class="string">&#x27;aaaaaa&#x27;</span>)</span><br><span class="line">    f.wasdf <span class="comment">#抛出异常，交给__exit__处理</span></span><br><span class="line"></span><br><span class="line">练习：模拟Open</span><br></pre></td></tr></table></figure>



<h4 id="1-4-16-类的装饰器"><a href="#1-4-16-类的装饰器" class="headerlink" title="1.4.16 类的装饰器"></a>1.4.16 类的装饰器</h4><p>无参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;类的装饰器开始运行啦------&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate </span><span class="comment">#无参:People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,salary</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br></pre></td></tr></table></figure>

<p>带参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类的装饰器开始运行啦------&gt;&#x27;</span>,kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"><span class="meta">@typeassert(<span class="params">name=<span class="built_in">str</span>,age=<span class="built_in">int</span>,salary=<span class="built_in">float</span></span>) </span><span class="comment">#有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,salary</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-4-17-再看property"><a href="#1-4-17-再看property" class="headerlink" title="1.4.17 再看property"></a>1.4.17 再看property</h4><p>用法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @AAA.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @AAA.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;delete的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br><span class="line"></span><br><span class="line">用法一</span><br></pre></td></tr></table></figure>

<p>用法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_AAA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_AAA</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set的时候运行我啊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_AAA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;delete的时候运行我啊&#x27;</span>)</span><br><span class="line">    AAA=<span class="built_in">property</span>(get_AAA,set_AAA,delete_AAA) <span class="comment">#内置property三个参数与get,set,delete一一对应</span></span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br><span class="line"></span><br><span class="line">用法二</span><br></pre></td></tr></table></figure>

<h4 id="1-4-18-元类-metaclass"><a href="#1-4-18-元类-metaclass" class="headerlink" title="1.4.18 元类 metaclass"></a>1.4.18 元类 metaclass</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/8029564.html">http://www.cnblogs.com/linhaifeng/articles/8029564.html</a></p>
<p><img src="./image/7.png"></p>
<h5 id="class关键字创建类的流程分析"><a href="#class关键字创建类的流程分析" class="headerlink" title="class关键字创建类的流程分析"></a>class关键字创建类的流程分析</h5><p>上文我们基于python中一切皆为对象的概念分析出：我们用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type</p>
<p>class关键字在帮我们创建类时，必然帮我们调用了元类OldboyTeacher=type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是<br>1、类名class_name=’OldboyTeacher’<br>2、基类们class_bases=(object,)<br>3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的<br>调用type时会依次传入以上三个参数<br>综上，class关键字帮我们创建一个类应该细分为以下四个过程<br><img src="./image/8.png"></p>
<p>自定义元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymeta</span>(<span class="params"><span class="built_in">type</span></span>):</span> <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment">#self=&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span></span><br><span class="line">        <span class="comment">#1、调用__new__产生一个空对象obj</span></span><br><span class="line">        obj=self.__new__(self) <span class="comment"># 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#2、调用__init__初始化空对象obj</span></span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在初始化之后，obj.__dict__里就有值了</span></span><br><span class="line">        obj.__dict__=&#123;<span class="string">&#x27;_%s__%s&#x27;</span> %(self.__name__,k):v <span class="keyword">for</span> k,v <span class="keyword">in</span> obj.__dict__.items()&#125;</span><br><span class="line">        <span class="comment">#3、返回初始化好的对象obj</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldboyTeacher</span>(<span class="params"><span class="built_in">object</span>,metaclass=Mymeta</span>):</span></span><br><span class="line">    school=<span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the oldboy to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line">t1=OldboyTeacher(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(t1.__dict__) <span class="comment">#&#123;&#x27;_OldboyTeacher__name&#x27;: &#x27;egon&#x27;, &#x27;_OldboyTeacher__age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义元类控制类OldboyTeacher的调用"><a href="#自定义元类控制类OldboyTeacher的调用" class="headerlink" title="自定义元类控制类OldboyTeacher的调用"></a>自定义元类控制类OldboyTeacher的调用</h5><p>储备知识：<strong>call</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(self)</span><br><span class="line">        print(args)</span><br><span class="line">        print(kwargs)</span><br><span class="line"></span><br><span class="line">obj=Foo()</span><br><span class="line">#1、要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法，该方法会在调用对象时自动触发</span><br><span class="line">#2、调用obj的返回值就是__call__方法的返回值</span><br><span class="line">res=obj(1,2,3,x=1,y=2) </span><br></pre></td></tr></table></figure>

<p>由上例得知，调用一个对象，就是触发对象所在类中的__call__方法的执行，如果把OldboyTeacher也当做一个对象，那么在OldboyTeacher这个对象的类中也必然存在一个__call__方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(self) #&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span><br><span class="line">        print(args) #(&#x27;egon&#x27;, 18)</span><br><span class="line">        print(kwargs) #&#123;&#125;</span><br><span class="line">        return 123</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass=Mymeta):</span><br><span class="line">    school=&#x27;oldboy&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#x27;%s says welcome to the oldboy to learn Python&#x27; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用OldboyTeacher就是在调用OldboyTeacher类中的__call__方法</span><br><span class="line"># 然后将OldboyTeacher传给self,溢出的位置参数传给*，溢出的关键字参数传给**</span><br><span class="line"># 调用OldboyTeacher的返回值就是调用__call__的返回值</span><br><span class="line">t1=OldboyTeacher(&#x27;egon&#x27;,18)</span><br><span class="line">print(t1) #123</span><br></pre></td></tr></table></figure>

<p>默认地，调用t1=OldboyTeacher(‘egon’,18)会做三件事<br>1、产生一个空对象obj<br>2、调用__init__方法初始化对象obj<br>3、返回初始化好的obj<br>对应着，OldboyTeacher类中的__call__方法也应该做这三件事</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span><br><span class="line">        #1、调用__new__产生一个空对象obj</span><br><span class="line">        obj=self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span><br><span class="line"></span><br><span class="line">        #2、调用__init__初始化空对象obj</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        #3、返回初始化好的对象obj</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass=Mymeta):</span><br><span class="line">    school=&#x27;oldboy&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#x27;%s says welcome to the oldboy to learn Python&#x27; %self.name)</span><br><span class="line"></span><br><span class="line">t1=OldboyTeacher(&#x27;egon&#x27;,18)</span><br><span class="line">print(t1.__dict__) #&#123;&#x27;name&#x27;: &#x27;egon&#x27;, &#x27;age&#x27;: 18&#125;</span><br></pre></td></tr></table></figure>

<p>上例的__call__相当于一个模板，我们可以在该基础上改写__call__的逻辑从而控制调用OldboyTeacher的过程，比如将OldboyTeacher的对象的所有属性都变成私有的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span><br><span class="line">        #1、调用__new__产生一个空对象obj</span><br><span class="line">        obj=self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span><br><span class="line"></span><br><span class="line">        #2、调用__init__初始化空对象obj</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        # 在初始化之后，obj.__dict__里就有值了</span><br><span class="line">        obj.__dict__=&#123;&#x27;_%s__%s&#x27; %(self.__name__,k):v for k,v in obj.__dict__.items()&#125;</span><br><span class="line">        #3、返回初始化好的对象obj</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass=Mymeta):</span><br><span class="line">    school=&#x27;oldboy&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#x27;%s says welcome to the oldboy to learn Python&#x27; %self.name)</span><br><span class="line"></span><br><span class="line">t1=OldboyTeacher(&#x27;egon&#x27;,18)</span><br><span class="line">print(t1.__dict__) #&#123;&#x27;_OldboyTeacher__name&#x27;: &#x27;egon&#x27;, &#x27;_OldboyTeacher__age&#x27;: 18&#125;</span><br></pre></td></tr></table></figure>

<p>上例中涉及到查找属性的问题，比如self.__new__，请看下一小节</p>
<h5 id="再看属性查找"><a href="#再看属性查找" class="headerlink" title="再看属性查找"></a>再看属性查找</h5><p>结合python继承的实现原理+元类重新看属性的查找应该是什么样子呢？？？<br>在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象OldboyTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    n=444</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class Bar(object):</span><br><span class="line">    n=333</span><br><span class="line"></span><br><span class="line">class Foo(Bar):</span><br><span class="line">    n=222</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(Foo,metaclass=Mymeta):</span><br><span class="line">    n=111</span><br><span class="line"></span><br><span class="line">    school=&#x27;oldboy&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#x27;%s says welcome to the oldboy to learn Python&#x27; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(OldboyTeacher.n) #自下而上依次注释各个类中的n=xxx，然后重新运行程序，发现n的查找顺序为OldboyTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type</span><br></pre></td></tr></table></figure>

<p>于是属性查找应该分成两层，一层是对象层（基于c3算法的MRO）的查找，另外一个层则是类层（即元类层）的查找</p>
<p><img src="./image/9.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查找顺序：</span><br><span class="line">#1、先对象层：OldoyTeacher-&gt;Foo-&gt;Bar-&gt;object</span><br><span class="line">#2、然后元类层：Mymeta-&gt;type</span><br></pre></td></tr></table></figure>

<p>依据上述总结，我们来分析下元类Mymeta中__call__里的self.__new__的查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Mymeta(type): </span><br><span class="line">    n=444</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.OldboyTeacher&#x27;&gt;</span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        print(self.__new__ is object.__new__) #True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bar(object):</span><br><span class="line">    n=333</span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#x27;Bar.__new__&#x27;)</span><br><span class="line"></span><br><span class="line">class Foo(Bar):</span><br><span class="line">    n=222</span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#x27;Foo.__new__&#x27;)</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(Foo,metaclass=Mymeta):</span><br><span class="line">    n=111</span><br><span class="line"></span><br><span class="line">    school=&#x27;oldboy&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#x27;%s says welcome to the oldboy to learn Python&#x27; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#x27;OldboyTeacher.__new__&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OldboyTeacher(&#x27;egon&#x27;,18) #触发OldboyTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找 </span><br></pre></td></tr></table></figure>

<p>总结，Mymeta下的<code>__call__</code>里的<code>self.__new__</code>在OldboyTeacher、Foo、Bar里都没有找到<code>__new__</code>的情况下，会去找object里的<code>__new__</code>，而object下默认就有一个<code>__new__</code>，所以即便是之前的类均未实现<code>__new__</code>,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找<code>__new__</code></p>
<p>我们在元类的__call__中也可以用object.<strong>new</strong>(self)去造对象</p>
<p><img src="./image/10.png"></p>
<p><strong>但我们还是推荐在<code>__call__</code>中使用<code>self.__new__（self）</code>去创造空对象，因为这种方式会检索三个类OldboyTeacher-&gt;Foo-&gt;Bar,而<code>object.__new__</code>则是直接跨过了他们三个</strong></p>
<p>最后说明一点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymeta</span>(<span class="params"><span class="built_in">type</span></span>):</span> <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        obj=<span class="built_in">type</span>.__new__(cls,*args,**kwargs) <span class="comment"># 必须按照这种传值方式</span></span><br><span class="line">        <span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">        <span class="comment"># return obj # 只有在返回值是type的对象时，才会触发下面的__init__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,class_name,class_bases,class_dic</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run。。。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldboyTeacher</span>(<span class="params"><span class="built_in">object</span>,metaclass=Mymeta</span>):</span> <span class="comment">#OldboyTeacher=Mymeta(&#x27;OldboyTeacher&#x27;,(object),&#123;...&#125;)</span></span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;oldboy&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the oldboy to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Mymeta)) <span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 产生类OldboyTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法</span></span><br><span class="line"><span class="comment"># 该方法中同样需要做至少三件事：</span></span><br><span class="line"><span class="comment"># class type:</span></span><br><span class="line"><span class="comment">#     def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.Mymeta&#x27;&gt;</span></span><br><span class="line"><span class="comment">#         obj=self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象</span></span><br><span class="line"><span class="comment">#         self.__init__(obj,*args,**kwargs) </span></span><br><span class="line"><span class="comment">#         return obj</span></span><br></pre></td></tr></table></figure>

<h3 id="2-软件目录结构规范"><a href="#2-软件目录结构规范" class="headerlink" title="2. 软件目录结构规范"></a>2. 软件目录结构规范</h3><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p>
<ol>
<li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li>
<li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li>
</ol>
<p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p>
<ol>
<li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li>
<li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li>
</ol>
<p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p>
<h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Foo</span><br><span class="line">|-- <span class="built_in">bin</span>/             </span><br><span class="line">|   |-- <span class="comment">#执行文件，启动脚本，初始化脚本（小的脚本文件，相当于程序入口）</span></span><br><span class="line">|-- conf/</span><br><span class="line">|   |-- <span class="comment">#配置文件</span></span><br><span class="line">|-- db/</span><br><span class="line">|   |-- <span class="comment">#保存数据,可以细分</span></span><br><span class="line">|-- lib/</span><br><span class="line">|   |-- <span class="comment">#公共的类库</span></span><br><span class="line">|-- log/</span><br><span class="line">|   |-- <span class="comment">#日志信息，调试信息，报错信息</span></span><br><span class="line">|-- src/       <span class="comment">#core/</span></span><br><span class="line">|   |-- <span class="comment">#核心的逻辑</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application">这个问题</a>上，能看到大家对Python目录结构的讨论。</p>
<p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p>
<p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>

<p>简要解释一下:</p>
<ol>
<li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li>
<li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li>
<li><code>docs/</code>: 存放一些文档。</li>
<li><code>setup.py</code>: 安装、部署、打包的脚本。</li>
<li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li>
<li><code>README</code>: 项目说明文件。</li>
</ol>
<p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a target="_blank" rel="noopener" href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/">这篇文章</a>。</p>
<p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p>
<h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p>
<p>它需要说明以下几个事项:</p>
<ol>
<li>软件定位，软件的基本功能。</li>
<li>运行代码的方法: 安装环境、启动命令等。</li>
<li>简要的使用说明。</li>
<li>代码目录结构说明，更详细点可以说明软件的基本原理。</li>
<li>常见问题说明。</li>
</ol>
<p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p>
<p>可以参考Redis源码中<a target="_blank" rel="noopener" href="https://github.com/antirez/redis#what-is-redis">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p>
<h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a target="_blank" rel="noopener" href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p>
<p>这个我是踩过坑的。</p>
<p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p>
<ol>
<li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li>
<li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li>
<li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li>
<li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li>
</ol>
<p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p>
<p>setuptools的<a target="_blank" rel="noopener" href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a target="_blank" rel="noopener" href="https://github.com/mitsuhiko/flask/blob/master/setup.py">setup.py</a></p>
<p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p>
<h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p>
<ol>
<li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li>
<li>方便读者明确项目使用了哪些Python包。</li>
</ol>
<p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a target="_blank" rel="noopener" href="https://pip.readthedocs.org/en/1.1/requirements.html">点这里</a>。</p>
<h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p>
<ol>
<li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li>
<li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li>
</ol>
<p>这种做法我不太赞同:</p>
<ol>
<li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li>
<li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li>
<li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li>
</ol>
<p>所以，我认为配置的使用，更好的方式是，</p>
<ol>
<li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li>
<li>程序的配置也是可以灵活控制的。</li>
</ol>
<p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p>
<p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p>
<h2 id="七、异常处理"><a href="#七、异常处理" class="headerlink" title="七、异常处理"></a>七、异常处理</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/6232220.html">http://www.cnblogs.com/linhaifeng/articles/6232220.html</a></p>
<p><strong>常用的异常种类</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入/输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[<span class="number">5</span>]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，</span><br><span class="line">导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br></pre></td></tr></table></figure>

<p><strong>如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AGE=10</span><br><span class="line">while True:</span><br><span class="line">    age=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的</span><br><span class="line">        age=int(age)</span><br><span class="line">        if age == AGE:</span><br><span class="line">            print(&#x27;you got it&#x27;)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p><strong>如果错误发生的条件是不可预知的，则需要用到try…except：在错误发生之后进行处理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#基本语法为</span><br><span class="line">try:</span><br><span class="line">    被检测的代码块</span><br><span class="line">except 异常类型：</span><br><span class="line">    try中一旦检测到异常，就执行这个位置的逻辑</span><br><span class="line">#举例</span><br><span class="line">try:</span><br><span class="line">    f=open(&#x27;a.txt&#x27;)</span><br><span class="line">    g=(line.strip() for line in f)</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">except StopIteration:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">#1 异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。</span><br><span class="line">s1 = &#x27;hello&#x27;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e: # 未捕获到异常，程序直接报错</span><br><span class="line">    print e</span><br><span class="line"></span><br><span class="line">#2 多分支</span><br><span class="line">s1 = &#x27;hello&#x27;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#3 万能异常Exception</span><br><span class="line">s1 = &#x27;hello&#x27;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#4 多分支异常与万能异常</span><br><span class="line">#4.1 如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们，那么骚年，大胆的去做吧，只有一个Exception就足够了。</span><br><span class="line">#4.2 如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了。</span><br><span class="line"></span><br><span class="line">#5 也可以在多分支后来一个Exception</span><br><span class="line">s1 = &#x27;hello&#x27;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#6 异常的其他机构</span><br><span class="line">s1 = &#x27;hello&#x27;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line">#except Exception as e:</span><br><span class="line">#    print(e)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;try内代码块没有异常则执行我&#x27;)</span><br><span class="line">finally:</span><br><span class="line">    print(&#x27;无论异常与否,都会执行该模块,通常是进行清理工作&#x27;)</span><br><span class="line"></span><br><span class="line">#7 主动触发异常</span><br><span class="line">try:</span><br><span class="line">    raise TypeError(&#x27;类型错误&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#8 自定义异常</span><br><span class="line">class EgonException(BaseException):</span><br><span class="line">    def __init__(self,msg):</span><br><span class="line">        self.msg=msg</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.msg</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise EgonException(&#x27;类型错误&#x27;)</span><br><span class="line">except EgonException as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#9 断言:assert 条件</span><br><span class="line">assert 1 == 1  </span><br><span class="line">assert 1 == 2</span><br><span class="line"></span><br><span class="line">#10 总结try..except</span><br><span class="line"></span><br><span class="line">1：把错误处理和真正的工作分开来</span><br><span class="line">2：代码更易组织，更清晰，复杂的工作任务更容易实现；</span><br><span class="line">3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了；</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://keelii.com/2018/09/24/socket-programming-in-python/">https://keelii.com/2018/09/24/socket-programming-in-python/</a>(<a target="_blank" rel="noopener" href="https://keelii.com/2018/09/24/socket-programming-in-python/">Python 中的Socket 编程（指南）</a>)</p>
<h2 id="八、socket编程"><a href="#八、socket编程" class="headerlink" title="八、socket编程"></a>八、socket编程</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaifeng/articles/6129246.html">https://www.cnblogs.com/linhaifeng/articles/6129246.html</a></p>
<p>from socket import *</p>
<p>listen(5) :tcp—》back_log</p>
<p>recv（）—》等待内核态内存中的数据</p>
<p>send() –&gt;向内核态内存中发送数据</p>
<p>TCP双向连接，UDP不建立连接</p>
<h3 id="一-客户端-服务器架构"><a href="#一-客户端-服务器架构" class="headerlink" title="一 客户端/服务器架构"></a>一 客户端/服务器架构</h3><p>1.硬件C/S架构(打印机)</p>
<p>2.软件C/S架构</p>
<p>　　<em>互联网中处处是C/S架构</em></p>
<p>　　<em>如黄色网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种）</em></p>
<p>　　<em>腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）</em></p>
<p>C/S架构与socket的关系：</p>
<p><em>我们学习socket就是为了完成C/S架构的开发</em></p>
<h3 id="二-osi七层"><a href="#二-osi七层" class="headerlink" title="二 osi七层"></a>二 osi七层</h3><p><strong>引子：</strong></p>
<p><em>须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</em></p>
<p><em>如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</em></p>
<p><em>互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语</em></p>
<p><em>如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</em></p>
<p><em>人们按照分工不同把互联网协议从逻辑上划分了层级，</em></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/5937962.html">详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p>
<p><strong>为何学习socket一定要先学习互联网协议：</strong></p>
<p><em>1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件</em></p>
<p><em>2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的</em></p>
<p><em>3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。</em></p>
<p><em>4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅</em><img src="image/123.jpg" alt="img"><br>​                                                           图1</p>
<h3 id="三-socket层"><a href="#三-socket层" class="headerlink" title="三 socket层"></a>三 socket层</h3><p>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。 </p>
<p><img src="image/124.jpg" alt="img"></p>
<p> 　　　　　　　　　　　　　　　　　　　<strong>图2</strong></p>
<h3 id="四-socket是什么"><a href="#四-socket是什么" class="headerlink" title="四 socket是什么"></a>四 socket是什么</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序</span><br><span class="line"></span><br><span class="line">而程序的pid是同一台机器上不同进程或者线程的标识</span><br></pre></td></tr></table></figure>

<h3 id="五-套接字发展史及分类"><a href="#五-套接字发展史及分类" class="headerlink" title="五 套接字发展史及分类"></a>五 套接字发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 </p>
<p><em><strong>基于文件类型的套接字家族</strong></em></p>
<p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p><em><strong>基于网络类型的套接字家族</strong></em></p>
<p>套接字家族的名字：AF_INET</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="六-套接字工作流程"><a href="#六-套接字工作流程" class="headerlink" title="六 套接字工作流程"></a>六 套接字工作流程</h3><p>​       一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。</p>
<p><img src="image/125.jpg" alt="img">      </p>
<p>​                                           图3       </p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>
<p>socket()模块函数用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 import socket</span><br><span class="line"> 2 socket.socket(socket_family,socket_type,protocal=0)</span><br><span class="line"> 3 socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。</span><br><span class="line"> ## AF_UNIX  unix系统间通信（基于文件的传输），AF_INET 服务器之间通信（网络）</span><br><span class="line"> ## stream流套接字tcp，datagram数据包套接字udp</span><br><span class="line"> 4 </span><br><span class="line"> 5 获取tcp/ip套接字</span><br><span class="line"> 6 tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"> 7 </span><br><span class="line"> 8 获取udp/ip套接字</span><br><span class="line"> 9 udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">10 </span><br><span class="line">11 由于 socket 模块中有太多的属性。我们在这里破例使用了&#x27;from module import *&#x27;语句。使用 &#x27;from socket import *&#x27;,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。</span><br><span class="line">12 例如tcpSock = socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">服务端套接字函数</span><br><span class="line">s.bind()    绑定(主机,端口号)到套接字</span><br><span class="line">s.listen()  开始TCP监听</span><br><span class="line">s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来</span><br><span class="line"></span><br><span class="line">客户端套接字函数</span><br><span class="line">s.connect()     主动初始化TCP服务器连接</span><br><span class="line">s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</span><br><span class="line"></span><br><span class="line">公共用途的套接字函数</span><br><span class="line">s.recv()            接收TCP数据</span><br><span class="line">s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)</span><br><span class="line">s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)</span><br><span class="line">s.recvfrom()        接收UDP数据</span><br><span class="line">s.sendto()          发送UDP数据</span><br><span class="line">s.getpeername()     连接到当前套接字的远端的地址</span><br><span class="line">s.getsockname()     当前套接字的地址</span><br><span class="line">s.getsockopt()      返回指定套接字的参数</span><br><span class="line">s.setsockopt()      设置指定套接字的参数</span><br><span class="line">s.close()           关闭套接字</span><br><span class="line"></span><br><span class="line">面向锁的套接字方法</span><br><span class="line">s.setblocking()     设置套接字的阻塞与非阻塞模式</span><br><span class="line">s.settimeout()      设置阻塞套接字操作的超时时间</span><br><span class="line">s.gettimeout()      得到阻塞套接字操作的超时时间</span><br><span class="line"></span><br><span class="line">面向文件的套接字的函数</span><br><span class="line">s.fileno()          套接字的文件描述符</span><br><span class="line">s.makefile()        创建一个与该套接字相关的文件</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1：用打电话的流程快速描述socket通信</span><br><span class="line">2：服务端和客户端加上基于一次链接的循环通信</span><br><span class="line">3：客户端发送空，卡主，证明是从哪个位置卡的</span><br><span class="line">服务端：</span><br><span class="line">from socket import *</span><br><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,8081))</span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">conn,addr=phone.accept()</span><br><span class="line">while True:</span><br><span class="line">    data=conn.recv(1024)</span><br><span class="line">    print(&#x27;server===&gt;&#x27;)</span><br><span class="line">    print(data)</span><br><span class="line">    conn.send(data.upper())</span><br><span class="line">conn.close()</span><br><span class="line">phone.close()</span><br><span class="line">客户端：</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.connect((&#x27;127.0.0.1&#x27;,8081))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    phone.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    print(&#x27;client====&gt;&#x27;)</span><br><span class="line">    data=phone.recv(1024)</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">说明卡的原因：缓冲区为空recv就卡住，引出原理图</span><br><span class="line"></span><br><span class="line">4.演示客户端断开链接，服务端的情况，提供解决方法</span><br><span class="line"></span><br><span class="line">5.演示服务端不能重复接受链接，而服务器都是正常运行不断来接受客户链接的</span><br><span class="line"></span><br><span class="line">6:简单演示udp</span><br><span class="line">服务端</span><br><span class="line">from socket import *</span><br><span class="line">phone=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,8082))</span><br><span class="line">while True:</span><br><span class="line">    msg,addr=phone.recvfrom(1024)</span><br><span class="line">    phone.sendto(msg.upper(),addr)</span><br><span class="line">客户端</span><br><span class="line">from socket import *</span><br><span class="line">phone=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;)</span><br><span class="line">    phone.sendto(msg.encode(&#x27;utf-8&#x27;),(&#x27;127.0.0.1&#x27;,8082))</span><br><span class="line">    msg,addr=phone.recvfrom(1024)</span><br><span class="line">    print(msg)</span><br><span class="line"></span><br><span class="line">udp客户端可以并发演示</span><br><span class="line">udp客户端可以输入为空演示，说出recvfrom与recv的区别，暂且不提tcp流和udp报的概念，留到粘包去说</span><br></pre></td></tr></table></figure>





<h3 id="七-基于TCP的套接字"><a href="#七-基于TCP的套接字" class="headerlink" title="七 基于TCP的套接字"></a>七 基于TCP的套接字</h3><p><em><strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</strong></em></p>
<p><em><strong>tcp服务端</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 ss = socket() #创建服务器套接字</span><br><span class="line">2 ss.bind()      #把地址绑定到套接字</span><br><span class="line">3 ss.listen()      #监听链接</span><br><span class="line">4 inf_loop:      #服务器无限循环</span><br><span class="line">5     cs = ss.accept() #接受客户端链接</span><br><span class="line">6     comm_loop:         #通讯循环</span><br><span class="line">7         cs.recv()/cs.send() #对话(接收与发送)</span><br><span class="line">8     cs.close()    #关闭客户端套接字</span><br><span class="line">9 ss.close()        #关闭服务器套接字(可选)</span><br></pre></td></tr></table></figure>

<p><em><strong>tcp客户端</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 cs = socket()    # 创建客户套接字</span><br><span class="line">2 cs.connect()    # 尝试连接服务器</span><br><span class="line">3 comm_loop:        # 通讯循环</span><br><span class="line">4     cs.send()/cs.recv()    # 对话(发送/接收)</span><br><span class="line">5 cs.close()            # 关闭客户套接字</span><br></pre></td></tr></table></figure>



<p>socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)  #电话卡</span><br><span class="line">BUFSIZE=1024                #收发消息的尺寸</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机</span><br><span class="line">s.bind(ip_port) #手机插卡</span><br><span class="line">s.listen(5)     #手机待机</span><br><span class="line"></span><br><span class="line">conn,addr=s.accept()            #手机接电话</span><br><span class="line"># print(conn)</span><br><span class="line"># print(addr)</span><br><span class="line">print(&#x27;接到来自%s的电话&#x27; %addr[0])</span><br><span class="line"></span><br><span class="line">msg=conn.recv(BUFSIZE)             #听消息,听话</span><br><span class="line">print(msg,type(msg))</span><br><span class="line"></span><br><span class="line">conn.send(msg.upper())          #发消息,说话</span><br><span class="line"></span><br><span class="line">conn.close()                    #挂电话</span><br><span class="line"></span><br><span class="line">s.close()                       #手机关机</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)           #拨电话</span><br><span class="line"></span><br><span class="line">s.send(&#x27;linhaifeng nb&#x27;.encode(&#x27;utf-8&#x27;))         #发消息,说话(只能发送字节类型)</span><br><span class="line"></span><br><span class="line">feedback=s.recv(BUFSIZE)                           #收消息,听话</span><br><span class="line">print(feedback.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">s.close()                                       #挂电话</span><br></pre></td></tr></table></figure>

<p>加上链接循环与通信循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8081)#电话卡</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机</span><br><span class="line">s.bind(ip_port) #手机插卡</span><br><span class="line">s.listen(5)     #手机待机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:                         #新增接收链接循环,可以不停的接电话</span><br><span class="line">    conn,addr=s.accept()            #手机接电话</span><br><span class="line">    # print(conn)</span><br><span class="line">    # print(addr)</span><br><span class="line">    print(&#x27;接到来自%s的电话&#x27; %addr[0])</span><br><span class="line">    while True:                         #新增通信循环,可以不断的通信,收发消息</span><br><span class="line">        msg=conn.recv(BUFSIZE)             #听消息,听话</span><br><span class="line"></span><br><span class="line">        # if len(msg) == 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生</span><br><span class="line"></span><br><span class="line">        print(msg,type(msg))</span><br><span class="line"></span><br><span class="line">        conn.send(msg.upper())          #发消息,说话</span><br><span class="line"></span><br><span class="line">    conn.close()                    #挂电话</span><br><span class="line"></span><br><span class="line">s.close()                       #手机关机</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8081)</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)           #拨电话</span><br><span class="line"></span><br><span class="line">while True:                             #新增通信循环,客户端可以不断发收消息</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    s.send(msg.encode(&#x27;utf-8&#x27;))         #发消息,说话(只能发送字节类型)</span><br><span class="line"></span><br><span class="line">    feedback=s.recv(BUFSIZE)                           #收消息,听话</span><br><span class="line">    print(feedback.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">s.close()                                       #挂电话</span><br></pre></td></tr></table></figure>



<p>问题：</p>
<p>有的同学在重启服务端时可能会遇到</p>
<p><img src="image/126.png" alt="img"></p>
<p>这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）</p>
<p>解决方法：</p>
<p><strong>(1)重用端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#加入一条socket配置，重用ip和端口</span><br><span class="line"></span><br><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,8080))</span><br></pre></td></tr></table></figure>

<p>(2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，</span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">编辑文件，加入以下内容：</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"> </span><br><span class="line">然后执行 /sbin/sysctl -p 让参数生效。</span><br><span class="line"> </span><br><span class="line">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

<h3 id="八-基于UDP的套接字"><a href="#八-基于UDP的套接字" class="headerlink" title="八 基于UDP的套接字"></a>八 基于UDP的套接字</h3><p><em><strong>udp是无链接的，先启动哪一端都不会报错</strong></em></p>
<p>udp服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ss = socket()   #创建一个服务器的套接字</span><br><span class="line">2 ss.bind()       #绑定服务器套接字</span><br><span class="line">3 inf_loop:       #服务器无限循环</span><br><span class="line">4     cs = ss.recvfrom()/ss.sendto() # 对话(接收与发送)</span><br><span class="line">5 ss.close()                         # 关闭服务器套接字</span><br></pre></td></tr></table></figure>

<p>udp客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs = socket()   # 创建客户套接字</span><br><span class="line">comm_loop:      # 通讯循环</span><br><span class="line">    cs.sendto()/cs.recvfrom()   # 对话(发送/接收)</span><br><span class="line">cs.close()                      # 关闭客户套接字</span><br></pre></td></tr></table></figure>

<p><em><strong>udp套接字简单示例</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(msg,addr)</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if not msg:continue</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port)</span><br><span class="line"></span><br><span class="line">    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(back_msg.decode(&#x27;utf-8&#x27;),addr)</span><br></pre></td></tr></table></figure>

<p><strong>qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8081)</span><br><span class="line">udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #买手机</span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_msg,addr=udp_server_sock.recvfrom(1024)</span><br><span class="line">    print(&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27; %(addr[0],addr[1],qq_msg.decode(&#x27;utf-8&#x27;)))</span><br><span class="line">    back_msg=input(&#x27;回复消息: &#x27;).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(&#x27;utf-8&#x27;),addr)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    &#x27;狗哥alex&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;瞎驴&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;一棵树&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;武大郎&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_name=input(&#x27;请选择聊天对象: &#x27;).strip()</span><br><span class="line">    while True:</span><br><span class="line">        msg=input(&#x27;请输入消息,回车发送: &#x27;).strip()</span><br><span class="line">        if msg == &#x27;quit&#x27;:break</span><br><span class="line">        if not msg or not qq_name or qq_name not in qq_name_dic:continue</span><br><span class="line">        udp_client_socket.sendto(msg.encode(&#x27;utf-8&#x27;),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27; %(addr[0],addr[1],back_msg.decode(&#x27;utf-8&#x27;)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    &#x27;狗哥alex&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;瞎驴&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;一棵树&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">    &#x27;武大郎&#x27;:(&#x27;127.0.0.1&#x27;,8081),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_name=input(&#x27;请选择聊天对象: &#x27;).strip()</span><br><span class="line">    while True:</span><br><span class="line">        msg=input(&#x27;请输入消息,回车发送: &#x27;).strip()</span><br><span class="line">        if msg == &#x27;quit&#x27;:break</span><br><span class="line">        if not msg or not qq_name or qq_name not in qq_name_dic:continue</span><br><span class="line">        udp_client_socket.sendto(msg.encode(&#x27;utf-8&#x27;),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(&#x27;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#x27; %(addr[0],addr[1],back_msg.decode(&#x27;utf-8&#x27;)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<p>服务端运行结果</p>
<p><img src="image/127.png" alt="img"></p>
<p>客户端1运行结果</p>
<p><img src="image/128.png" alt="img"></p>
<p>客户端2运行结果</p>
<p><img src="image/129.png" alt="img"></p>
<p><em><strong>时间服务器</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">from time import strftime</span><br><span class="line"></span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)</span><br><span class="line">bufsize=1024</span><br><span class="line"></span><br><span class="line">tcp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg,addr=tcp_server.recvfrom(bufsize)</span><br><span class="line">    print(&#x27;===&gt;&#x27;,msg)</span><br><span class="line">    </span><br><span class="line">    if not msg:</span><br><span class="line">        time_fmt=&#x27;%Y-%m-%d %X&#x27;</span><br><span class="line">    else:</span><br><span class="line">        time_fmt=msg.decode(&#x27;utf-8&#x27;)</span><br><span class="line">    back_msg=strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(&#x27;utf-8&#x27;),addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9000)</span><br><span class="line">bufsize=1024</span><br><span class="line"></span><br><span class="line">tcp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;请输入时间格式(例%Y %m %d)&gt;&gt;: &#x27;).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port)</span><br><span class="line"></span><br><span class="line">    data=tcp_client.recv(bufsize)</span><br><span class="line"></span><br><span class="line">    print(data.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">tcp_client.close()</span><br></pre></td></tr></table></figure>

<h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）</p>
<p><strong>注意注意注意：</strong></p>
<p>res=subprocess.Popen(cmd.decode(‘utf-8’),<br>shell=True,<br>stderr=subprocess.PIPE,<br>stdout=subprocess.PIPE)</p>
<p>的结果的编码是以当前所在的系统为准的，如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p>
<p><strong>且只能从管道里读一次结果</strong></p>
<p>注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line">BUFSIZE=1024</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr=tcp_socket_server.accept()</span><br><span class="line">    print(&#x27;客户端&#x27;,addr)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        cmd=conn.recv(BUFSIZE)</span><br><span class="line">        if len(cmd) == 0:break</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),shell=True,</span><br><span class="line">                         stdout=subprocess.PIPE,</span><br><span class="line">                         stdin=subprocess.PIPE,</span><br><span class="line">                         stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr=act_res.stderr.read()</span><br><span class="line">        stdout=act_res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    if msg == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    act_res=s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    print(act_res.decode(&#x27;utf-8&#x27;),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于tcp的socket，在运行时会发生粘包</p>
<p> 让我们再基于udp制作一个远程执行命令的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line"></span><br><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9003)</span><br><span class="line">bufsize=1024</span><br><span class="line"></span><br><span class="line">udp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    #收消息</span><br><span class="line">    cmd,addr=udp_server.recvfrom(bufsize)</span><br><span class="line">    print(&#x27;用户命令-----&gt;&#x27;,cmd)</span><br><span class="line"></span><br><span class="line">    #逻辑处理</span><br><span class="line">    res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),shell=True,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)</span><br><span class="line">    stderr=res.stderr.read()</span><br><span class="line">    stdout=res.stdout.read()</span><br><span class="line"></span><br><span class="line">    #发消息</span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,9003)</span><br><span class="line">bufsize=1024</span><br><span class="line"></span><br><span class="line">udp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port)</span><br><span class="line"></span><br><span class="line">    data,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    print(data.decode(&#x27;utf-8&#x27;),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>上述程序是基于udp的socket，在运行时永远不会发生粘包</p>
<h3 id="十-什么是粘包"><a href="#十-什么是粘包" class="headerlink" title="十 什么是粘包"></a>十 什么是粘包</h3><p>须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来</p>
<p>首先需要掌握一个socket收发消息的原理</p>
<p><img src="image/130.png" alt="img"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。</p>
<p>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p>
<p>此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">算法</a>把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li>
<li><strong>tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略</strong></li>
</ol>
<p>udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠</p>
<p>tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</p>
<p><em><strong>两种情况下会发生粘包。</strong></em></p>
<p>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据量很小，会合到一起，产生粘包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(10)</span><br><span class="line">data2=conn.recv(10)</span><br><span class="line"></span><br><span class="line">print(&#x27;-----&gt;&#x27;,data1.decode(&#x27;utf-8&#x27;))</span><br><span class="line">print(&#x27;-----&gt;&#x27;,data2.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">s.send(&#x27;feng&#x27;.encode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(2) #一次没有收完整</span><br><span class="line">data2=conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的</span><br><span class="line"></span><br><span class="line">print(&#x27;-----&gt;&#x27;,data1.decode(&#x27;utf-8&#x27;))</span><br><span class="line">print(&#x27;-----&gt;&#x27;,data2.decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE=1024</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(&#x27;hello feng&#x27;.encode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>



<p><em><strong>拆包的发生情况</strong></em></p>
<p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。</p>
<p><em><strong>补充问题一：为何tcp是可靠传输，udp是不可靠传输</strong></em></p>
<p>基于tcp的数据传输请参考我的另一篇文章<a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaifeng/articles/5937962.html%EF%BC%8Ctcp%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%97%B6%EF%BC%8C%E5%8F%91%E9%80%81%E7%AB%AF%E5%85%88%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%AD%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%B0%86%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%91%E5%BE%80%E5%AF%B9%E7%AB%AF%EF%BC%8C%E5%AF%B9%E7%AB%AF%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAack=1%EF%BC%8C%E5%8F%91%E9%80%81%E7%AB%AF%E5%88%99%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AF%B9%E7%AB%AF%E8%BF%94%E5%9B%9Eack=0%EF%BC%8C%E5%88%99%E9%87%8D%E6%96%B0%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%89%80%E4%BB%A5tcp%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84">http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的</a></p>
<p>而udp发送数据，对端是不会返回确认信息的，因此不可靠</p>
<p><em><strong>补充问题二：send(字节流)和recv(1024)及sendall</strong></em></p>
<p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据</p>
<p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失</p>
<h3 id="十一-解决粘包的low比处理方法"><a href="#十一-解决粘包的low比处理方法" class="headerlink" title="十一 解决粘包的low比处理方法"></a>十一 解决粘包的low比处理方法</h3><p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据</p>
<p>low版本的解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket,subprocess</span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line">s.bind(ip_port)</span><br><span class="line">s.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr=s.accept()</span><br><span class="line">    print(&#x27;客户端&#x27;,addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg=conn.recv(1024)</span><br><span class="line">        if not msg:break</span><br><span class="line">        res=subprocess.Popen(msg.decode(&#x27;utf-8&#x27;),shell=True,\</span><br><span class="line">                            stdin=subprocess.PIPE,\</span><br><span class="line">                         stderr=subprocess.PIPE,\</span><br><span class="line">                         stdout=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        if err:</span><br><span class="line">            ret=err</span><br><span class="line">        else:</span><br><span class="line">            ret=res.stdout.read()</span><br><span class="line">        data_length=len(ret)</span><br><span class="line">        conn.send(str(data_length).encode(&#x27;utf-8&#x27;))</span><br><span class="line">        data=conn.recv(1024).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        if data == &#x27;recv_ready&#x27;:</span><br><span class="line">            conn.sendall(ret)</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket,time</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    if msg == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    length=int(s.recv(1024).decode(&#x27;utf-8&#x27;))</span><br><span class="line">    s.send(&#x27;recv_ready&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    send_size=0</span><br><span class="line">    recv_size=0</span><br><span class="line">    data=b&#x27;&#x27;</span><br><span class="line">    while recv_size &lt; length:</span><br><span class="line">        data+=s.recv(1024)</span><br><span class="line">        recv_size+=len(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(data.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p>为何low：</p>
<p>程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</p>
<h3 id="十二-峰哥解决粘包的方法"><a href="#十二-峰哥解决粘包的方法" class="headerlink" title="十二 峰哥解决粘包的方法"></a>十二 峰哥解决粘包的方法</h3><p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p>
<p><strong>struct模块</strong> </p>
<p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<p>&gt;&gt;&gt; struct.pack(‘i’,1111111111111)</p>
<p>。。。。。。。。。</p>
<p>struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</p>
<p><img src="image/131.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import json,struct</span><br><span class="line">#假设通过客户端上传1T:1073741824000的文件a.txt</span><br><span class="line"></span><br><span class="line">#为避免粘包,必须自定制报头</span><br><span class="line">header=&#123;&#x27;file_size&#x27;:1073741824000,&#x27;file_name&#x27;:&#x27;/a/b/c/d/e/a.txt&#x27;,&#x27;md5&#x27;:&#x27;8f6fbf8347faa4924a76856701edb0f3&#x27;&#125; #1T数据,文件路径和md5值</span><br><span class="line"></span><br><span class="line">#为了该报头能传送,需要序列化并且转为bytes</span><br><span class="line">head_bytes=bytes(json.dumps(header),encoding=&#x27;utf-8&#x27;) #序列化并转成bytes,用于传输</span><br><span class="line"></span><br><span class="line">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span><br><span class="line">head_len_bytes=struct.pack(&#x27;i&#x27;,len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度</span><br><span class="line"></span><br><span class="line">#客户端开始发送</span><br><span class="line">conn.send(head_len_bytes) #先发报头的长度,4个bytes</span><br><span class="line">conn.send(head_bytes) #再发报头的字节格式</span><br><span class="line">conn.sendall(文件内容) #然后发真实内容的字节格式</span><br><span class="line"></span><br><span class="line">#服务端开始接收</span><br><span class="line">head_len_bytes=s.recv(4) #先收报头4个bytes,得到报头长度的字节格式</span><br><span class="line">x=struct.unpack(&#x27;i&#x27;,head_len_bytes)[0] #提取报头的长度</span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) #按照报头长度x,收取报头的bytes格式</span><br><span class="line">header=json.loads(json.dumps(header)) #提取报头</span><br><span class="line"></span><br><span class="line">#最后根据报头的内容提取真实的数据,比如</span><br><span class="line">real_data_len=s.recv(header[&#x27;file_size&#x27;])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">import ctypes</span><br><span class="line"></span><br><span class="line">values1 = (1, &#x27;abc&#x27;.encode(&#x27;utf-8&#x27;), 2.7)</span><br><span class="line">values2 = (&#x27;defg&#x27;.encode(&#x27;utf-8&#x27;),101)</span><br><span class="line">s1 = struct.Struct(&#x27;I3sf&#x27;)</span><br><span class="line">s2 = struct.Struct(&#x27;4sI&#x27;)</span><br><span class="line"></span><br><span class="line">print(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line">print(&#x27;Before : &#x27;,binascii.hexlify(prebuffer))</span><br><span class="line"># t=binascii.hexlify(&#x27;asdfaf&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,0,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line">print(&#x27;After pack&#x27;,binascii.hexlify(prebuffer))</span><br><span class="line">print(s1.unpack_from(prebuffer,0))</span><br><span class="line">print(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(&#x27;ii&#x27;)</span><br><span class="line">s3.pack_into(prebuffer,0,123,123)</span><br><span class="line">print(&#x27;After pack&#x27;,binascii.hexlify(prebuffer))</span><br><span class="line">print(s3.unpack_from(prebuffer,0))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import socket,struct,json</span><br><span class="line">import subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line"></span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    while True:</span><br><span class="line">        cmd=conn.recv(1024)</span><br><span class="line">        if not cmd:break</span><br><span class="line">        print(&#x27;cmd: %s&#x27; %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                             shell=True,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        if err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        else:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(&#x27;i&#x27;,len(back_msg))) #先发back_msg的长度</span><br><span class="line">        conn.sendall(back_msg) #在发真实的内容</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">import socket,time,struct</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">    if len(msg) == 0:continue</span><br><span class="line">    if msg == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l=s.recv(4)</span><br><span class="line">    x=struct.unpack(&#x27;i&#x27;,l)[0]</span><br><span class="line">    print(type(x),x)</span><br><span class="line">    # print(struct.unpack(&#x27;I&#x27;,l))</span><br><span class="line">    r_s=0</span><br><span class="line">    data=b&#x27;&#x27;</span><br><span class="line">    while r_s &lt; x:</span><br><span class="line">        r_d=s.recv(1024)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=len(r_d)</span><br><span class="line"></span><br><span class="line">    # print(data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    print(data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码</span><br></pre></td></tr></table></figure>

<p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<p>发送时：<br>先发报头长度<br>再编码报头内容然后发送<br>最后发真实内容</p>
<p>接收时：<br>先手报头长度，用struct取出来<br>根据取出的长度收取报头内容，然后解码，反序列化<br>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import socket,struct,json</span><br><span class="line">import subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line"></span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    while True:</span><br><span class="line">        cmd=conn.recv(1024)</span><br><span class="line">        if not cmd:break</span><br><span class="line">        print(&#x27;cmd: %s&#x27; %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                             shell=True,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        if err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        else:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;&#x27;data_size&#x27;:len(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(&#x27;i&#x27;,len(head_json_bytes))) #先发报头的长度</span><br><span class="line">        conn.send(head_json_bytes) #再发报头</span><br><span class="line">        conn.sendall(back_msg) #在发真实的内容</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import struct,json</span><br><span class="line"></span><br><span class="line">ip_port=(&#x27;127.0.0.1&#x27;,8080)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd=input(&#x27;&gt;&gt;: &#x27;)</span><br><span class="line">    if not cmd:continue</span><br><span class="line">    client.send(bytes(cmd,encoding=&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">    head=client.recv(4)</span><br><span class="line">    head_json_len=struct.unpack(&#x27;i&#x27;,head)[0]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(&#x27;utf-8&#x27;))</span><br><span class="line">    data_len=head_json[&#x27;data_size&#x27;]</span><br><span class="line"></span><br><span class="line">    recv_size=0</span><br><span class="line">    recv_data=b&#x27;&#x27;</span><br><span class="line">    while recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(1024)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    #print(recv_data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码</span><br></pre></td></tr></table></figure>


<p>FTP作业：上传下载文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import subprocess</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class MYTCPServer:</span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = False</span><br><span class="line"></span><br><span class="line">    max_packet_size = 8192</span><br><span class="line"></span><br><span class="line">    coding=&#x27;utf-8&#x27;</span><br><span class="line"></span><br><span class="line">    request_queue_size = 5</span><br><span class="line"></span><br><span class="line">    server_dir=&#x27;file_upload&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, bind_and_activate=True):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if bind_and_activate:</span><br><span class="line">            try:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            except:</span><br><span class="line">                self.server_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def server_bind(self):</span><br><span class="line">        &quot;&quot;&quot;Called by constructor to bind the socket.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.allow_reuse_address:</span><br><span class="line">            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        self.socket.bind(self.server_address)</span><br><span class="line">        self.server_address = self.socket.getsockname()</span><br><span class="line"></span><br><span class="line">    def server_activate(self):</span><br><span class="line">        &quot;&quot;&quot;Called by constructor to activate the server.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br><span class="line"></span><br><span class="line">    def server_close(self):</span><br><span class="line">        &quot;&quot;&quot;Called to clean-up the server.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def get_request(self):</span><br><span class="line">        &quot;&quot;&quot;Get the request and client address from the socket.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.socket.accept()</span><br><span class="line"></span><br><span class="line">    def close_request(self, request):</span><br><span class="line">        &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span><br><span class="line">        request.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            self.conn,self.client_addr=self.get_request()</span><br><span class="line">            print(&#x27;from client &#x27;,self.client_addr)</span><br><span class="line">            while True:</span><br><span class="line">                try:</span><br><span class="line">                    head_struct = self.conn.recv(4)</span><br><span class="line">                    if not head_struct:break</span><br><span class="line"></span><br><span class="line">                    head_len = struct.unpack(&#x27;i&#x27;, head_struct)[0]</span><br><span class="line">                    head_json = self.conn.recv(head_len).decode(self.coding)</span><br><span class="line">                    head_dic = json.loads(head_json)</span><br><span class="line"></span><br><span class="line">                    print(head_dic)</span><br><span class="line">                    #head_dic=&#123;&#x27;cmd&#x27;:&#x27;put&#x27;,&#x27;filename&#x27;:&#x27;a.txt&#x27;,&#x27;filesize&#x27;:123123&#125;</span><br><span class="line">                    cmd=head_dic[&#x27;cmd&#x27;]</span><br><span class="line">                    if hasattr(self,cmd):</span><br><span class="line">                        func=getattr(self,cmd)</span><br><span class="line">                        func(head_dic)</span><br><span class="line">                except Exception:</span><br><span class="line">                    break</span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        file_path=os.path.normpath(os.path.join(</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[&#x27;filename&#x27;]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize=args[&#x27;filesize&#x27;]</span><br><span class="line">        recv_size=0</span><br><span class="line">        print(&#x27;-----&gt;&#x27;,file_path)</span><br><span class="line">        with open(file_path,&#x27;wb&#x27;) as f:</span><br><span class="line">            while recv_size &lt; filesize:</span><br><span class="line">                recv_data=self.conn.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size+=len(recv_data)</span><br><span class="line">                print(&#x27;recvsize:%s filesize:%s&#x27; %(recv_size,filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpserver1=MYTCPServer((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">tcpserver1.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#下列代码与本题无关</span><br><span class="line">class MYUDPServer:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;UDP server class.&quot;&quot;&quot;</span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_DGRAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = False</span><br><span class="line"></span><br><span class="line">    max_packet_size = 8192</span><br><span class="line"></span><br><span class="line">    coding=&#x27;utf-8&#x27;</span><br><span class="line"></span><br><span class="line">    def get_request(self):</span><br><span class="line">        data, client_addr = self.socket.recvfrom(self.max_packet_size)</span><br><span class="line">        return (data, self.socket), client_addr</span><br><span class="line"></span><br><span class="line">    def server_activate(self):</span><br><span class="line">        # No need to call listen() for UDP.</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def shutdown_request(self, request):</span><br><span class="line">        # No need to shutdown anything.</span><br><span class="line">        self.close_request(request)</span><br><span class="line"></span><br><span class="line">    def close_request(self, request):</span><br><span class="line">        # No need to close anything.</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MYTCPClient:</span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = False</span><br><span class="line"></span><br><span class="line">    max_packet_size = 8192</span><br><span class="line"></span><br><span class="line">    coding=&#x27;utf-8&#x27;</span><br><span class="line"></span><br><span class="line">    request_queue_size = 5</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, connect=True):</span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if connect:</span><br><span class="line">            try:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            except:</span><br><span class="line">                self.client_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def client_connect(self):</span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    def client_close(self):</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            inp=input(&quot;&gt;&gt;: &quot;).strip()</span><br><span class="line">            if not inp:continue</span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[0]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func=getattr(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        cmd=args[0]</span><br><span class="line">        filename=args[1]</span><br><span class="line">        if not os.path.isfile(filename):</span><br><span class="line">            print(&#x27;file:%s is not exists&#x27; %filename)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;&#x27;cmd&#x27;:cmd,&#x27;filename&#x27;:os.path.basename(filename),&#x27;filesize&#x27;:filesize&#125;</span><br><span class="line">        print(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(&#x27;i&#x27;,len(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=0</span><br><span class="line">        with open(filename,&#x27;rb&#x27;) as f:</span><br><span class="line">            for line in f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=len(line)</span><br><span class="line">                print(send_size)</span><br><span class="line">            else:</span><br><span class="line">                print(&#x27;upload successful&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>

<h3 id="十三-认证客户端的链接合法性"><a href="#十三-认证客户端的链接合法性" class="headerlink" title="十三 认证客户端的链接合法性"></a>十三 认证客户端的链接合法性</h3><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<p>服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=b&#x27;linhaifeng bang bang bang&#x27;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    认证客户端链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;开始验证新链接的合法性&#x27;)</span><br><span class="line">    msg=os.urandom(32)</span><br><span class="line">    conn.sendall(msg)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    respone=conn.recv(len(digest))</span><br><span class="line">    return hmac.compare_digest(respone,digest)</span><br><span class="line"></span><br><span class="line">def data_handler(conn,bufsize=1024):</span><br><span class="line">    if not conn_auth(conn):</span><br><span class="line">        print(&#x27;该链接不合法,关闭&#x27;)</span><br><span class="line">        conn.close()</span><br><span class="line">        return</span><br><span class="line">    print(&#x27;链接合法,开始通信&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        data=conn.recv(bufsize)</span><br><span class="line">        if not data:break</span><br><span class="line">        conn.sendall(data.upper())</span><br><span class="line"></span><br><span class="line">def server_handler(ip_port,bufsize,backlog=5):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    只处理链接</span><br><span class="line">    :param ip_port:</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_server.bind(ip_port)</span><br><span class="line">    tcp_socket_server.listen(backlog)</span><br><span class="line">    while True:</span><br><span class="line">        conn,addr=tcp_socket_server.accept()</span><br><span class="line">        print(&#x27;新连接[%s:%s]&#x27; %(addr[0],addr[1]))</span><br><span class="line">        data_handler(conn,bufsize)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ip_port=(&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line">    bufsize=1024</span><br><span class="line">    server_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端（合法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=b&#x27;linhaifeng bang bang bang&#x27;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    验证客户端到服务器的链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    msg=conn.recv(32)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize=1024):</span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ip_port=(&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line">    bufsize=1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端（非法，不知道加密）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize=1024):</span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ip_port=(&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line">    bufsize=1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>

<p>客户端（非法，不知道secretkey）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Linhaifeng&#x27;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=b&#x27;linhaifeng bang bang bang1111&#x27;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    验证客户端到服务器的链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    msg=conn.recv(32)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize=1024):</span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data=input(&#x27;&gt;&gt;: &#x27;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data == &#x27;quit&#x27;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#x27;utf-8&#x27;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ip_port=(&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line">    bufsize=1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>





<h3 id="十四-socketserver实现并发"><a href="#十四-socketserver实现并发" class="headerlink" title="十四 socketserver实现并发"></a>十四 socketserver实现并发</h3><p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p>
<p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p>
<p>server类：</p>
<p><img src="image/132.png" alt="img"></p>
<p>request类：</p>
<p><img src="image/133.png" alt="img"></p>
<p>继承关系:</p>
<p><img src="image/134.png" alt="img"></p>
<p><img src="image/135.png" alt="img"></p>
<p> <img src="image/136.png" alt="img"></p>
<p>以下述代码为例，分析socketserver源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftpserver=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p>
<ol>
<li>实例化得到ftpserver，先找类ThreadingTCPServer的__init__,在TCPServer中找到，进而执行server_bind,server_active</li>
<li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li>
<li>执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li>
<li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li>
<li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找__init__方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li>
</ol>
<p>源码分析总结：</p>
<p>基于tcp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.server即套接字对象</li>
<li>　　self.request即一个链接</li>
<li>　　self.client_address即客户端地址</li>
</ol>
<p>基于udp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=(‘127.0.0.1’, 8080)&gt;)</li>
<li>　　self.client_address即客户端地址</li>
</ol>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import socketserver</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line">class FtpServer(socketserver.BaseRequestHandler):</span><br><span class="line">    coding=&#x27;utf-8&#x27;</span><br><span class="line">    server_dir=&#x27;file_upload&#x27;</span><br><span class="line">    max_packet_size=1024</span><br><span class="line">    BASE_DIR=os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(self.request)</span><br><span class="line">        while True:</span><br><span class="line">            data=self.request.recv(4)</span><br><span class="line">            data_len=struct.unpack(&#x27;i&#x27;,data)[0]</span><br><span class="line">            head_json=self.request.recv(data_len).decode(self.coding)</span><br><span class="line">            head_dic=json.loads(head_json)</span><br><span class="line">            # print(head_dic)</span><br><span class="line">            cmd=head_dic[&#x27;cmd&#x27;]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func=getattr(self,cmd)</span><br><span class="line">                func(head_dic)</span><br><span class="line">    def put(self,args):</span><br><span class="line">        file_path = os.path.normpath(os.path.join(</span><br><span class="line">            self.BASE_DIR,</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[&#x27;filename&#x27;]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize = args[&#x27;filesize&#x27;]</span><br><span class="line">        recv_size = 0</span><br><span class="line">        print(&#x27;-----&gt;&#x27;, file_path)</span><br><span class="line">        with open(file_path, &#x27;wb&#x27;) as f:</span><br><span class="line">            while recv_size &lt; filesize:</span><br><span class="line">                recv_data = self.request.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size += len(recv_data)</span><br><span class="line">                print(&#x27;recvsize:%s filesize:%s&#x27; % (recv_size, filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftpserver=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class MYTCPClient:</span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = False</span><br><span class="line"></span><br><span class="line">    max_packet_size = 8192</span><br><span class="line"></span><br><span class="line">    coding=&#x27;utf-8&#x27;</span><br><span class="line"></span><br><span class="line">    request_queue_size = 5</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, connect=True):</span><br><span class="line">        self.server_address=server_address</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if connect:</span><br><span class="line">            try:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            except:</span><br><span class="line">                self.client_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def client_connect(self):</span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    def client_close(self):</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            inp=input(&quot;&gt;&gt;: &quot;).strip()</span><br><span class="line">            if not inp:continue</span><br><span class="line">            l=inp.split()</span><br><span class="line">            cmd=l[0]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func=getattr(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        cmd=args[0]</span><br><span class="line">        filename=args[1]</span><br><span class="line">        if not os.path.isfile(filename):</span><br><span class="line">            print(&#x27;file:%s is not exists&#x27; %filename)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            filesize=os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic=&#123;&#x27;cmd&#x27;:cmd,&#x27;filename&#x27;:os.path.basename(filename),&#x27;filesize&#x27;:filesize&#125;</span><br><span class="line">        print(head_dic)</span><br><span class="line">        head_json=json.dumps(head_dic)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct=struct.pack(&#x27;i&#x27;,len(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size=0</span><br><span class="line">        with open(filename,&#x27;rb&#x27;) as f:</span><br><span class="line">            for line in f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+=len(line)</span><br><span class="line">                print(send_size)</span><br><span class="line">            else:</span><br><span class="line">                print(&#x27;upload successful&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client=MYTCPClient((&#x27;127.0.0.1&#x27;,8080))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>

<p> <strong>补充：</strong></p>
<p>两个程序之间通信:管道</p>
<h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanchenqi/articles/5733873.html">https://www.cnblogs.com/yuanchenqi/articles/5733873.html</a></p>
<h3 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h3><p>并发：系统具有处理多个任务（动作）的能力</p>
<p>并行：系统具有同时处理多个任务（动作）的能力</p>
<h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h3><p>同步：当进程执行到一个IO操作的时候—–等：同步</p>
<p>异步：当进程执行到一个IO操作的时候—–不等：等到数据接收成功，再回来处理</p>
<h3 id="python多进程"><a href="#python多进程" class="headerlink" title="python多进程"></a>python多进程</h3><p>多进程+协程</p>
<p>对于IO密集型任务，python多线程有用；对于计算密集型任务，不推荐多线程，可以使用多进程。</p>
<h3 id="python的GIL"><a href="#python的GIL" class="headerlink" title="python的GIL"></a>python的GIL</h3><p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
<p>上面的核心意思就是，<strong>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</strong></p>
<h2 id="十、python的线程与threading模块"><a href="#十、python的线程与threading模块" class="headerlink" title="十、python的线程与threading模块"></a>十、python的线程与threading模块</h2><h3 id="一-线程的两种调用方式"><a href="#一-线程的两种调用方式" class="headerlink" title="一 线程的两种调用方式"></a>一 线程的两种调用方式</h3><pre><code>  threading 模块建立在thread 模块之上。thread模块以低级、原始的方式来处理和控制线程，而threading 模块通过对thread进行二次封装，
</code></pre>
<p>提供了更方便的api来处理线程。</p>
<p><strong>直接调用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def sayhi(num): #定义每个线程要运行的函数</span><br><span class="line"> </span><br><span class="line">    print(&quot;running on number:%s&quot; %num)</span><br><span class="line"> </span><br><span class="line">    time.sleep(3)</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"> </span><br><span class="line">    t1 = threading.Thread(target=sayhi,args=(1,)) #生成一个线程实例</span><br><span class="line">    t2 = threading.Thread(target=sayhi,args=(2,)) #生成另一个线程实例</span><br><span class="line"> </span><br><span class="line">    t1.start() #启动线程</span><br><span class="line">    t2.start() #启动另一个线程</span><br><span class="line"> </span><br><span class="line">    print(t1.getName()) #获取线程名</span><br><span class="line">    print(t2.getName())</span><br></pre></td></tr></table></figure>

<p><strong>继承式调用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def __init__(self,num):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    def run(self):#定义每个线程要运行的函数</span><br><span class="line"></span><br><span class="line">        print(&quot;running on number:%s&quot; %self.num)</span><br><span class="line"></span><br><span class="line">        time.sleep(3)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    t1 = MyThread(1)</span><br><span class="line">    t2 = MyThread(2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line">    print(&quot;ending......&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="二-threading-thread的实例方法"><a href="#二-threading-thread的实例方法" class="headerlink" title="二 threading.thread的实例方法"></a>二 threading.thread的实例方法</h3><h4 id="join-amp-Daemon方法"><a href="#join-amp-Daemon方法" class="headerlink" title="join&amp;Daemon方法"></a>join&amp;Daemon方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from time import ctime,sleep</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def ListenMusic(name):</span><br><span class="line"></span><br><span class="line">        print (&quot;Begin listening to %s. %s&quot; %(name,ctime()))</span><br><span class="line">        sleep(3)</span><br><span class="line">        print(&quot;end listening %s&quot;%ctime())</span><br><span class="line"></span><br><span class="line">def RecordBlog(title):</span><br><span class="line"></span><br><span class="line">        print (&quot;Begin recording the %s! %s&quot; %(title,ctime()))</span><br><span class="line">        sleep(5)</span><br><span class="line">        print(&#x27;end recording %s&#x27;%ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=ListenMusic,args=(&#x27;水手&#x27;,))</span><br><span class="line">t2 = threading.Thread(target=RecordBlog,args=(&#x27;python线程&#x27;,))</span><br><span class="line"></span><br><span class="line">threads.append(t1)</span><br><span class="line">threads.append(t2)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    for t in threads:</span><br><span class="line">        #t.setDaemon(True) #注意:一定在start之前设置</span><br><span class="line">        t.start()</span><br><span class="line">        # t.join()</span><br><span class="line">    # t1.join()</span><br><span class="line">    t1.setDaemon(True)</span><br><span class="line"></span><br><span class="line">    #t2.join()########考虑这三种join位置下的结果？</span><br><span class="line">    print (&quot;all over %s&quot; %ctime())</span><br></pre></td></tr></table></figure>

<p>join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。</p>
<p>daemon：无交互后台程序</p>
<p>setDaemon(True)：（使线程与主线程一起退出）</p>
<pre><code>     将线程声明为守护线程，必须在start() 方法调用之前设置， 如果不设置为守护线程程序会被无限挂起。这个方法基本和join是相反的。
     当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以用etDaemon方法啦
</code></pre>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># run():  线程被cpu调度后自动执行线程对象的run方法</span><br><span class="line"># start():启动线程活动。</span><br><span class="line"># isAlive(): 返回线程是否活动的。</span><br><span class="line"># getName(): 返回线程名。</span><br><span class="line"># setName(): 设置线程名。</span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line"># threading.currentThread(): 返回当前的线程变量。</span><br><span class="line"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span><br><span class="line"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span><br></pre></td></tr></table></figure>

<h3 id="三-同步锁-Lock"><a href="#三-同步锁-Lock" class="headerlink" title="三 同步锁(Lock)"></a>三 同步锁(Lock)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def addNum():</span><br><span class="line">    global num #在每个线程中都获取这个全局变量</span><br><span class="line">    #num-=1</span><br><span class="line"></span><br><span class="line">    temp=num</span><br><span class="line">    #print(&#x27;--get num:&#x27;,num )</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    num =temp-1 #对此公共变量进行-1操作</span><br><span class="line"></span><br><span class="line">num = 100  #设定一个共享变量</span><br><span class="line">thread_list = []</span><br><span class="line">for i in range(100):</span><br><span class="line">    t = threading.Thread(target=addNum)</span><br><span class="line">    t.start()</span><br><span class="line">    thread_list.append(t)</span><br><span class="line"></span><br><span class="line">for t in thread_list: #等待所有线程执行完毕</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(&#x27;final num:&#x27;, num )</span><br></pre></td></tr></table></figure>

<p><strong>观察：time.sleep(0.1)  /0.001/0.0000001 结果分别是多少？</strong></p>
<p>多个线程都在同时操作同一个共享资源，所以造成了资源破坏，怎么办呢？(join会造成串行，失去所线程的意义)</p>
<p>我们可以通过同步锁来解决这种问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">R=threading.Lock()</span><br><span class="line">def sub():</span><br><span class="line">    global num</span><br><span class="line">    R.acquire()</span><br><span class="line">    temp=num-1</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    num=temp</span><br><span class="line">    R.release()</span><br></pre></td></tr></table></figure>

<h3 id="四-线程死锁和递归锁"><a href="#四-线程死锁和递归锁" class="headerlink" title="四 线程死锁和递归锁"></a>四 线程死锁和递归锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">class myThread(threading.Thread):</span><br><span class="line">    def doA(self):</span><br><span class="line">        lockA.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockA&quot;,time.ctime())</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        lockB.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockB&quot;,time.ctime())</span><br><span class="line">        lockB.release()</span><br><span class="line">        lockA.release()</span><br><span class="line"></span><br><span class="line">    def doB(self):</span><br><span class="line">        lockB.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockB&quot;,time.ctime())</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        lockA.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockA&quot;,time.ctime())</span><br><span class="line">        lockA.release()</span><br><span class="line">        lockB.release()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    lockA=threading.Lock()</span><br><span class="line">    lockB=threading.Lock()</span><br><span class="line">    threads=[]</span><br><span class="line">    for i in range(5):</span><br><span class="line">        threads.append(myThread())</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()#等待线程结束，后面再讲。</span><br></pre></td></tr></table></figure>

<p>解决办法：使用递归锁，将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock=threading.RLock()</span><br></pre></td></tr></table></figure>

<p>为了支持在<strong>同一线程中多次请求同一资源</strong>，python提供了“可重入锁”：threading.RLock。RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。直到一个线程所有的acquire都被release(count=0)，其他的线程才能获得资源。</p>
<p><strong>应用</strong></p>
<h3 id="同步条件-Event"><a href="#同步条件-Event" class="headerlink" title="同步条件(Event)"></a>同步条件(Event)</h3><p>An event is a simple synchronization object;the event represents an internal flag,</p>
<p>and threads can wait for the flag to be set, or set or clear the flag themselves.</p>
<p>event = threading.Event()</p>
<p># a client thread can wait for the flag to be set<br>event.wait()</p>
<p># a server thread can set or reset it<br>event.set()<br>event.clear()</p>
<p>If the flag is set, the wait method doesn’t do anything.<br>If the flag is cleared, wait will block until it becomes set again.<br>Any number of threads may wait for the same event.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class Boss(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;BOSS：今晚大家都要加班到22:00。&quot;)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line">        time.sleep(5)</span><br><span class="line">        print(&quot;BOSS：&lt;22:00&gt;可以下班了。&quot;)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line">class Worker(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        event.wait()</span><br><span class="line">        print(&quot;Worker：哎……命苦啊！&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        event.clear()</span><br><span class="line">        event.wait()</span><br><span class="line">        print(&quot;Worker：OhYeah!&quot;)</span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    event=threading.Event()</span><br><span class="line">    threads=[]</span><br><span class="line">    for i in range(5):</span><br><span class="line">        threads.append(Worker())</span><br><span class="line">    threads.append(Boss())</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure>



<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h3><pre><code>  信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。

  计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念)

  BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class myThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        if semaphore.acquire():</span><br><span class="line">            print(self.name)</span><br><span class="line">            time.sleep(5)</span><br><span class="line">            semaphore.release()</span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    semaphore=threading.Semaphore(5)</span><br><span class="line">    thrs=[]</span><br><span class="line">    for i in range(100):</span><br><span class="line">        thrs.append(myThread())</span><br><span class="line">    for t in thrs:</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<h3 id="多线程利器－－－队列-queue"><a href="#多线程利器－－－队列-queue" class="headerlink" title="多线程利器－－－队列(queue)"></a>多线程利器－－－队列(queue)</h3><h4 id="列表是不安全的数据结构"><a href="#列表是不安全的数据结构" class="headerlink" title="列表是不安全的数据结构"></a><strong>列表是不安全的数据结构</strong></h4><p><strong>思考：如何通过对列来完成上述功能？</strong></p>
<p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p>
<h4 id="queue列队类的方法"><a href="#queue列队类的方法" class="headerlink" title="queue列队类的方法"></a>queue列队类的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">创建一个“队列”对象</span><br><span class="line">import queue</span><br><span class="line">q = queue.Queue(maxsize = 10)</span><br><span class="line">Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。</span><br><span class="line"></span><br><span class="line">将一个值放入队列中</span><br><span class="line">q.put(10)</span><br><span class="line">调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为</span><br><span class="line">1。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。</span><br><span class="line"></span><br><span class="line">将一个值从队列中取出</span><br><span class="line">q.get()</span><br><span class="line">调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，</span><br><span class="line">get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。</span><br><span class="line"></span><br><span class="line">Python queue模块有三种队列及构造函数:</span><br><span class="line">1、Python Queue模块的FIFO队列先进先出。   class queue.Queue(maxsize)</span><br><span class="line">2、LIFO类似于堆，即先进后出。               class queue.LifoQueue(maxsize)</span><br><span class="line">3、还有一种是优先级队列级别越低越先出来。        class queue.PriorityQueue(maxsize)</span><br><span class="line">q.put([2,&quot;hello&quot;])   【&lt;级别&gt;，信息】</span><br><span class="line"></span><br><span class="line">此包中的常用方法(q = Queue.Queue()):</span><br><span class="line">q.qsize() 返回队列的大小</span><br><span class="line">q.empty() 如果队列为空，返回True,反之False</span><br><span class="line">q.full() 如果队列满了，返回True,反之False</span><br><span class="line">q.full 与 maxsize 大小对应</span><br><span class="line">q.get([block[, timeout]]) 获取队列，timeout等待时间</span><br><span class="line">q.get_nowait() 相当q.get(False)</span><br><span class="line">非阻塞 q.put(item) 写入队列，timeout等待时间</span><br><span class="line">q.put_nowait(item) 相当q.put(item, False)</span><br><span class="line">q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号</span><br><span class="line">q.join() 实际上意味着等到队列为空，再执行别的操作</span><br></pre></td></tr></table></figure>

<h4 id="task-done-amp-join"><a href="#task-done-amp-join" class="headerlink" title="task_done()&amp;join()"></a>task_done()&amp;join()</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49637086/python-what-is-queue-task-done-used-for">https://stackoverflow.com/questions/49637086/python-what-is-queue-task-done-used-for</a></p>
<p>If I give you a box of work assignments, do I care about when you’ve taken everything out of the box?</p>
<p>No. I care about when <strong>the work is done</strong>. Looking at an empty box doesn’t tell me that. You and 5 other guys might still be working on stuff you took out of the box.</p>
<p><code>Queue.task_done</code> lets workers say when a <em>task is done</em>. Someone waiting for all the work to be done with <code>Queue.join</code> will wait until enough <code>task_done</code> calls have been made, not when the queue is empty.</p>
<h4 id="生产者消费者模型："><a href="#生产者消费者模型：" class="headerlink" title="生产者消费者模型："></a><strong>生产者消费者模型：</strong></h4><p><strong>为什么要使用生产者和消费者模式</strong></p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p>
<p><strong>什么是生产者消费者模式</strong></p>
<p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个结耦的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import time,random</span><br><span class="line">import queue,threading</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line">def Producer(name):</span><br><span class="line">  count = 0</span><br><span class="line">  while count &lt;10:</span><br><span class="line">    print(&quot;making........&quot;)</span><br><span class="line">    time.sleep(random.randrange(3))</span><br><span class="line">    q.put(count)</span><br><span class="line">    print(&#x27;Producer %s has produced %s baozi..&#x27; %(name, count))</span><br><span class="line">    count +=1</span><br><span class="line">    #q.task_done()</span><br><span class="line">    #q.join()</span><br><span class="line">    print(&quot;ok......&quot;)</span><br><span class="line">def Consumer(name):</span><br><span class="line">  count = 0</span><br><span class="line">  while count &lt;10:</span><br><span class="line">    time.sleep(random.randrange(4))</span><br><span class="line">    if not q.empty():</span><br><span class="line">        data = q.get()</span><br><span class="line">        #q.task_done()</span><br><span class="line">        #q.join()</span><br><span class="line">        print(data)</span><br><span class="line">        print(&#x27;\033[32;1mConsumer %s has eat %s baozi...\033[0m&#x27; %(name, data))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;-----no baozi anymore----&quot;)</span><br><span class="line">    count +=1</span><br><span class="line"></span><br><span class="line">p1 = threading.Thread(target=Producer, args=(&#x27;A&#x27;,))</span><br><span class="line">c1 = threading.Thread(target=Consumer, args=(&#x27;B&#x27;,))</span><br><span class="line"># c2 = threading.Thread(target=Consumer, args=(&#x27;C&#x27;,))</span><br><span class="line"># c3 = threading.Thread(target=Consumer, args=(&#x27;D&#x27;,))</span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br><span class="line"># c2.start()</span><br><span class="line"># c3.start()</span><br></pre></td></tr></table></figure>



<h2 id="多进程模块-multiprocessing"><a href="#多进程模块-multiprocessing" class="headerlink" title="多进程模块 multiprocessing"></a>多进程模块 multiprocessing</h2><p><strong>十几个以内的多进程不用考虑资源消耗问题</strong></p>
<p>M<code>ultiprocessing</code> is a package that supports spawning processes using an API similar to the threading module. The <code>multiprocessing</code> package offers both local and remote concurrency,effectively side-stepping the <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/glossary.html#term-global-interpreter-lock">Global Interpreter Lock</a> by using subprocesses instead of threads. Due to this, the <code>multiprocessing</code> module allows the programmer to fully leverage multiple processors on a given machine. It runs on both Unix and Windows.</p>
<p>由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。</p>
<p>multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。</p>
<h3 id="一-进程的调用"><a href="#一-进程的调用" class="headerlink" title="一 进程的调用"></a>一 进程的调用</h3><h4 id="调用方式1"><a href="#调用方式1" class="headerlink" title="调用方式1"></a><strong>调用方式1</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">def f(name):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&#x27;hello&#x27;, name,time.ctime())</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    p_list=[]</span><br><span class="line">    for i in range(3):</span><br><span class="line">        p = Process(target=f, args=(&#x27;alvin&#x27;,))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    for i in p_list:</span><br><span class="line">        p.join()</span><br><span class="line">    print(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="调用方式2"><a href="#调用方式2" class="headerlink" title="调用方式2"></a><strong>调用方式2</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MyProcess(Process):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        #self.name = name</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print (&#x27;hello&#x27;, self.name,time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    p_list=[]</span><br><span class="line">    for i in range(3):</span><br><span class="line">        p = MyProcess()</span><br><span class="line">        p.start()</span><br><span class="line">        p_list.append(p)</span><br><span class="line"></span><br><span class="line">    for p in p_list:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure>

<p>To show the individual process IDs involved, here is an expanded example:<br>子进程—》父进程—》pycharm进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def info(title):</span><br><span class="line">  </span><br><span class="line">    print(&quot;title:&quot;,title)</span><br><span class="line">    print(&#x27;parent process:&#x27;, os.getppid())</span><br><span class="line">    print(&#x27;process id:&#x27;, os.getpid())</span><br><span class="line"></span><br><span class="line">def f(name):</span><br><span class="line">    info(&#x27;function f&#x27;)</span><br><span class="line">    print(&#x27;hello&#x27;, name)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    info(&#x27;main process line&#x27;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;------------------&quot;)</span><br><span class="line">    p = Process(target=info, args=(&#x27;yuan&#x27;,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<h3 id="二-Process类"><a href="#二-Process类" class="headerlink" title="二 Process类"></a>二 Process类</h3><p><strong>构造方法：</strong></p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
<p>　　group: 线程组，目前还没有实现，库引用中提示必须是None；<br>　　target: 要执行的方法；<br>　　name: 进程名；<br>　　args/kwargs: 要传入方法的参数。</p>
<p><strong>实例方法：</strong></p>
<p>　　is_alive()：返回进程是否在运行。</p>
<p>　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</p>
<p>　　start()：进程准备就绪，等待CPU调度</p>
<p>　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</p>
<p>　　terminate()：不管任务是否完成，立即停止工作进程</p>
<p><strong>属性：</strong></p>
<p>　　daemon：和线程的setDeamon功能一样</p>
<p>　　name：进程名字。</p>
<p>　　pid：进程号。</p>
<h3 id="三-进程间通讯"><a href="#三-进程间通讯" class="headerlink" title="三 进程间通讯"></a>三 进程间通讯</h3><h4 id="3-1-进程对列Queue"><a href="#3-1-进程对列Queue" class="headerlink" title="3.1 进程对列Queue"></a><strong>3.1 进程对列Queue</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def f(q,n):</span><br><span class="line">    #q.put([123, 456, &#x27;hello&#x27;])</span><br><span class="line">    q.put(n*n+1)</span><br><span class="line">    print(&quot;son process&quot;,id(q))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    q = Queue()  #try: q=queue.Queue()</span><br><span class="line">    print(&quot;main process&quot;,id(q))</span><br><span class="line"></span><br><span class="line">    for i in range(3):</span><br><span class="line">        p = Process(target=f, args=(q,i))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br></pre></td></tr></table></figure>

<h4 id="3-2-管道"><a href="#3-2-管道" class="headerlink" title="3.2 管道"></a><strong>3.2 管道</strong></h4><p>The<code> Pipe()</code> function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Pipe</span><br><span class="line"></span><br><span class="line">def f(conn):</span><br><span class="line">    conn.send([12, &#123;&quot;name&quot;:&quot;yuan&quot;&#125;, &#x27;hello&#x27;])</span><br><span class="line">    response=conn.recv()</span><br><span class="line">    print(&quot;response&quot;,response)</span><br><span class="line">    conn.close()</span><br><span class="line">    print(&quot;q_ID2:&quot;,id(child_conn))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    print(&quot;q_ID1:&quot;,id(child_conn))</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   # prints &quot;[42, None, &#x27;hello&#x27;]&quot;</span><br><span class="line">    parent_conn.send(&quot;儿子你好!&quot;)</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>The two connection objects returned by <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Pipe"><code>Pipe()</code></a> represent the two ends of the pipe. Each connection object has <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Connection.send"><code>send()</code></a> and <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Connection.recv"><code>recv()</code></a> methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the <em>same</em> end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</p>
<h4 id="3-3-Managers-数据共享"><a href="#3-3-Managers-数据共享" class="headerlink" title="3.3 Managers(数据共享)"></a><strong>3.3 Managers</strong>(数据共享)</h4><p><strong>Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。</strong></p>
<p>A manager object returned by <code>Manager()</code> controls a server process which holds Python objects and allows other processes to manipulate them using proxies.</p>
<p>A manager returned by <code>Manager()</code> will support types <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/stdtypes.html#list"><code>list</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/stdtypes.html#dict"><code>dict</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.managers.Namespace"><code>Namespace</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Lock"><code>Lock</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.RLock"><code>RLock</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Semaphore"><code>Semaphore</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.BoundedSemaphore"><code>BoundedSemaphore</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Condition"><code>Condition</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Event"><code>Event</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Barrier"><code>Barrier</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Queue"><code>Queue</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Value"><code>Value</code></a> and <a target="_blank" rel="noopener" href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Array"><code>Array</code></a>. For example：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line"></span><br><span class="line">def f(d, l,n):</span><br><span class="line">    d[n] = &#x27;1&#x27;</span><br><span class="line">    d[&#x27;2&#x27;] = 2</span><br><span class="line">    d[0.25] = None</span><br><span class="line">    l.append(n)</span><br><span class="line">    #print(l)</span><br><span class="line"></span><br><span class="line">    print(&quot;son process:&quot;,id(d),id(l))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    with Manager() as manager:</span><br><span class="line"></span><br><span class="line">        d = manager.dict()</span><br><span class="line"></span><br><span class="line">        l = manager.list(range(5))</span><br><span class="line"></span><br><span class="line">        print(&quot;main process:&quot;,id(d),id(l))</span><br><span class="line"></span><br><span class="line">        p_list = []</span><br><span class="line"></span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d,l,i))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line"></span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure>

<h3 id="四-进程同步"><a href="#四-进程同步" class="headerlink" title="四 进程同步"></a>四 进程同步</h3><p>Without using the lock output from the different processes is liable to get all mixed up.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Lock</span><br><span class="line"></span><br><span class="line">def f(l, i):</span><br><span class="line">  </span><br><span class="line">    with l.acquire():</span><br><span class="line">        print(&#x27;hello world %s&#x27;%i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    for num in range(10):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br></pre></td></tr></table></figure>

<h3 id="五-进程池"><a href="#五-进程池" class="headerlink" title="五 进程池"></a>五 进程池</h3><p>回调函数：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19801131">https://www.zhihu.com/question/19801131</a></p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>进程池中有两个方法：</p>
<ul>
<li>apply</li>
<li>apply_async</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from  multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line"></span><br><span class="line">def Foo(i):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(i)</span><br><span class="line">    return i+100</span><br><span class="line"></span><br><span class="line">def Bar(arg):</span><br><span class="line"></span><br><span class="line">    print(os.getpid())</span><br><span class="line">    print(os.getppid())</span><br><span class="line">    print(&#x27;logger:&#x27;,arg)</span><br><span class="line"></span><br><span class="line">pool = Pool(5)</span><br><span class="line"></span><br><span class="line">Bar(1)</span><br><span class="line">print(&quot;----------------&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    #pool.apply(func=Foo, args=(i,)) # 串行，平时不用</span><br><span class="line">    #pool.apply_async(func=Foo, args=(i,))</span><br><span class="line">    pool.apply_async(func=Foo, args=(i,),callback=Bar) #callback回调函数</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join() # join和close的调用顺序是固定的</span><br><span class="line">print(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="四-Python中的上下文管理器-contextlib模块"><a href="#四-Python中的上下文管理器-contextlib模块" class="headerlink" title="四 Python中的上下文管理器(contextlib模块)"></a>四 Python中的上下文管理器(<strong>contextlib模块</strong>)</h2><p><strong>上下文管理器的任务是：代码块执行前准备，代码块执行后收拾</strong></p>
<h3 id="1-如何使用上下文管理器："><a href="#1-如何使用上下文管理器：" class="headerlink" title="1 如何使用上下文管理器："></a><strong>1 如何使用上下文管理器：</strong></h3><p>如何打开一个文件，并写入”hello world”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;my.txt&quot;</span><br><span class="line">mode=&quot;w&quot;</span><br><span class="line">f=open(filename,mode)</span><br><span class="line">f.write(&quot;hello world&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>当发生异常时（如磁盘写满），就没有机会执行第5行。当然，我们可以采用try-finally语句块进行包装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writer=open(filename,mode)</span><br><span class="line">try:</span><br><span class="line">    writer.write(&quot;hello world&quot;)</span><br><span class="line">finally:</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure>

<p>当我们进行复杂的操作时，try-finally语句就会变得丑陋，采用with语句重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(filename,mode) as writer:</span><br><span class="line">    writer.write(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>

<p>as指代了从open()函数返回的内容，并把它赋给了新值。with完成了try-finally的任务。</p>
<h3 id="2-自定义上下文管理器"><a href="#2-自定义上下文管理器" class="headerlink" title="2 自定义上下文管理器"></a><strong>2 自定义上下文管理器</strong></h3><p>with语句的作用类似于try-finally，提供一种上下文机制。要应用with语句的类，其内部必须提供两个内置函数__enter__和__exit__。前者在主体代码执行前执行，后者在主体代码执行后执行。as后面的变量，是在__enter__函数中返回的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class echo():</span><br><span class="line">    def output(self):</span><br><span class="line">        print &quot;hello world&quot;</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print &quot;enter&quot;</span><br><span class="line">        return self  #可以返回任何希望返回的东西</span><br><span class="line">    def __exit__(self,exception_type,value,trackback):</span><br><span class="line">        print &quot;exit&quot;</span><br><span class="line">        if exception_type==ValueError:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return Flase</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt;with echo as e:</span><br><span class="line">    e.output()</span><br><span class="line">     </span><br><span class="line">输出：</span><br><span class="line">enter</span><br><span class="line">hello world</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>完备的__exit__函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def __exit__(self,exc_type,exc_value,exc_tb)</span><br></pre></td></tr></table></figure>

<p>其中，exc_type:异常类型；exc_value:异常值；exc_tb:异常追踪信息</p>
<p>当__exit__返回True时，异常不传播</p>
<h3 id="3-contextlib模块"><a href="#3-contextlib模块" class="headerlink" title="3 contextlib模块"></a>3 contextlib模块</h3><p>contextlib模块的作用是提供更易用的上下文管理器，它是通过Generator实现的。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，常用框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">@contextmanager</span><br><span class="line">def make_context():</span><br><span class="line">    print &#x27;enter&#x27;</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;ok&quot;</span><br><span class="line">    except RuntimeError,err:</span><br><span class="line">        print &#x27;error&#x27;,err</span><br><span class="line">    finally:</span><br><span class="line">        print &#x27;exit&#x27;</span><br><span class="line">         </span><br><span class="line">&gt;&gt;&gt;with make_context() as value:</span><br><span class="line">    print value</span><br><span class="line">     </span><br><span class="line">输出为：</span><br><span class="line">    enter</span><br><span class="line">    ok</span><br><span class="line">    exit</span><br></pre></td></tr></table></figure>

<p>其中，yield写入try-finally中是为了保证异常安全（能处理异常）as后的变量的值是由yield返回。yield前面的语句可看作代码块执行前操作，yield之后的操作可以看作在__exit__函数中的操作。</p>
<p>以线程锁为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@contextlib.contextmanager</span><br><span class="line">def loudLock():</span><br><span class="line">    print &#x27;Locking&#x27;</span><br><span class="line">    lock.acquire()</span><br><span class="line">    yield</span><br><span class="line">    print &#x27;Releasing&#x27;</span><br><span class="line">    lock.release()</span><br><span class="line"> </span><br><span class="line">with loudLock():</span><br><span class="line">    print &#x27;Lock is locked: %s&#x27; % lock.locked()</span><br><span class="line">    print &#x27;Doing something that needs locking&#x27;</span><br><span class="line"> </span><br><span class="line">#Output:</span><br><span class="line">#Locking</span><br><span class="line">#Lock is locked: True</span><br><span class="line">#Doing something that needs locking</span><br><span class="line">#Releasing</span><br></pre></td></tr></table></figure>

<h3 id="4-contextlib-nested-减少嵌套"><a href="#4-contextlib-nested-减少嵌套" class="headerlink" title="4 contextlib.nested:减少嵌套"></a><strong>4 contextlib.nested:减少嵌套</strong></h3><p><strong>对于：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(filename,mode) as reader:</span><br><span class="line">    with open(filename1,mode1) as writer:</span><br><span class="line">        writer.write(reader.read())</span><br></pre></td></tr></table></figure>

<p>可以通过contextlib.nested进行简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with contextlib.nested(open(filename,mode),open(filename1,mode1)) as (reader,writer):</span><br><span class="line">    writer.write(reader.read())</span><br></pre></td></tr></table></figure>

<p>在python 2.7及以后，被一种新的语法取代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(filename,mode) as reader,open(filename1,mode1) as writer:</span><br><span class="line">    writer.write(reader.read())</span><br></pre></td></tr></table></figure>

<h3 id="5-contextlib-closing"><a href="#5-contextlib-closing" class="headerlink" title="5 contextlib.closing()"></a><strong>5 contextlib.closing()</strong></h3><p>file类直接支持上下文管理器API，但有些表示打开句柄的对象并不支持，如urllib.urlopen()返回的对象。还有些遗留类，使用close()方法而不支持上下文管理器API。为了确保关闭句柄，需要使用closing()为它创建一个上下文管理器（调用类的close方法）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;__init__&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;close()&#x27;</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">with</span> contextlib.closing(myclass()):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">__init__</span><br><span class="line">ok</span><br><span class="line">close()</span><br></pre></td></tr></table></figure>

<h2 id="十一、协程"><a href="#十一、协程" class="headerlink" title="十一、协程"></a>十一、协程</h2><p>协程主要面向IO操作</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>优点1: 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>优点2: <strong>不需要多线程的锁机制</strong>，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<h3 id="yield的简单实现"><a href="#yield的简单实现" class="headerlink" title="yield的简单实现"></a>yield的简单实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;---&gt;ready to eat baozi...&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        new_baozi = yield</span><br><span class="line">        print(&quot;[%s] is eating baozi %s&quot; % (name,new_baozi))</span><br><span class="line">        #time.sleep(1)</span><br><span class="line"></span><br><span class="line">def producer():</span><br><span class="line"></span><br><span class="line">    r = con.__next__()</span><br><span class="line">    r = con2.__next__()</span><br><span class="line">    n = 0</span><br><span class="line">    while 1:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;\033[32;1m[producer]\033[0m is making baozi %s and %s&quot; %(n,n+1) )</span><br><span class="line">        con.send(n)</span><br><span class="line">        con2.send(n+1)</span><br><span class="line"></span><br><span class="line">        n +=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    con = consumer(&quot;c1&quot;)</span><br><span class="line">    con2 = consumer(&quot;c2&quot;)</span><br><span class="line">    p = producer()</span><br></pre></td></tr></table></figure>

<h3 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h3><p>greenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(34)</span><br><span class="line">    gr2.switch()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(78)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>

<h3 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h3><p>【<a target="_blank" rel="noopener" href="https://softlns.github.io/2015/11/28/python-gevent/">https://softlns.github.io/2015/11/28/python-gevent/</a>】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import gevent</span><br><span class="line">import requests,time</span><br><span class="line"></span><br><span class="line">start=time.time()</span><br><span class="line"></span><br><span class="line">def f(url):</span><br><span class="line">    print(&#x27;GET: %s&#x27; % url)</span><br><span class="line">    resp =requests.get(url)</span><br><span class="line">    data = resp.text</span><br><span class="line">    print(&#x27;%d bytes received from %s.&#x27; % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line"></span><br><span class="line">        gevent.spawn(f, &#x27;https://www.python.org/&#x27;),</span><br><span class="line">        gevent.spawn(f, &#x27;https://www.yahoo.com/&#x27;),</span><br><span class="line">        gevent.spawn(f, &#x27;https://www.baidu.com/&#x27;),</span><br><span class="line">        gevent.spawn(f, &#x27;https://www.sina.com.cn/&#x27;),</span><br><span class="line"></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># f(&#x27;https://www.python.org/&#x27;)</span><br><span class="line">#</span><br><span class="line"># f(&#x27;https://www.yahoo.com/&#x27;)</span><br><span class="line">#</span><br><span class="line"># f(&#x27;https://baidu.com/&#x27;)</span><br><span class="line">#</span><br><span class="line"># f(&#x27;https://www.sina.com.cn/&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;cost time:&quot;,time.time()-start)</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yuanchenqi/articles/5722574.html">http://www.cnblogs.com/yuanchenqi/articles/5722574.html</a></p>
<h2 id="十二、IO模型"><a href="#十二、IO模型" class="headerlink" title="十二、IO模型"></a>十二、IO模型</h2><h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>上节的问题：<br>协程：遇到IO操作就切换。<br>但什么时候切回去呢？怎么确定IO操作完了？</p>
<p>传统的编程是如下线性模式的：</p>
<p>开始—&gt;代码块A—&gt;代码块B—&gt;代码块C—&gt;代码块D—&gt;……—&gt;结束</p>
<p>每一个代码块里是完成各种各样事情的代码，但编程者知道代码块A,B,C,D…的执行顺序，唯一能够改变这个流程的是数据。输入不同的数据，根据条件语句判断，流程或许就改为A—&gt;C—&gt;E…—&gt;结束。每一次程序运行顺序或许都不同，但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身），那你就知道接下来甚至一直到结束它的运行流程。</p>
<p> 对于事件驱动型程序模型，它的流程大致如下：</p>
<p>开始—&gt;初始化—&gt;等待</p>
<p> 与上面传统编程模式不同，事件驱动程序在启动之后，就在那等待，等待什么呢？等待被事件触发。传统编程下也有“等待”的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。但这与下面的等待不同，传统编程的“等待”，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，也不强制用户输入或者干什么。只要某一事件发生，那程序就会做出相应的“反应”。这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。</p>
<h3 id="一、事件驱动模型介绍"><a href="#一、事件驱动模型介绍" class="headerlink" title="一、事件驱动模型介绍"></a>一、事件驱动模型介绍</h3><p>通常，我们写服务器处理模型的程序时，有以下几种模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）每收到一个请求，创建一个新的进程，来处理该请求； </span><br><span class="line">（2）每收到一个请求，创建一个新的线程，来处理该请求； </span><br><span class="line">（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</span><br></pre></td></tr></table></figure>

<p>第三种就是协程、事件驱动的方式，一般普遍认为第（3）种方式是大多数网络服务器采用的方式 </p>
<p><strong>论事件驱动模型</strong> </p>
<p><img src="image/ContractedBlock-1558531626082.gif" alt="img"> 事件驱动之鼠标点击事件注册</p>
<p>在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？ 两种方式：</p>
<h4 id="1创建一个线程循环检测是否有鼠标点击"><a href="#1创建一个线程循环检测是否有鼠标点击" class="headerlink" title="1创建一个线程循环检测是否有鼠标点击"></a>1创建一个线程循环检测是否有鼠标点击</h4><p>​      那么这个方式有以下几个缺点：</p>
<ol>
<li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li>
<li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li>
<li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>所以，该方式是非常不好的。</li>
</ol>
<h4 id="2-就是事件驱动模型"><a href="#2-就是事件驱动模型" class="headerlink" title="2 就是事件驱动模型"></a>2 就是事件驱动模型</h4><p>目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：</p>
<ol>
<li>有一个事件（消息）队列；</li>
<li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="image/20161012022913536" alt="这里写图片描述"><br><strong>事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理</strong>。另外两种常见的编程范式是（单线程）同步以及多线程编程。<br>　<br>让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。<br><img src="image/20161012023013850" alt="这里写图片描述"></li>
</ol>
<p>最初的问题：怎么确定IO操作完了切回去呢？<strong>通过回调函数</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu.</span><br><span class="line">2.再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。</span><br><span class="line">3.事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。</span><br><span class="line">4.事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。</span><br><span class="line">5.事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。</span><br><span class="line">6.目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。</span><br></pre></td></tr></table></figure>

<p>注意，事件驱动的监听事件是由操作系统调用的cpu来完成的</p>
<h2 id="十三、IO多路复用"><a href="#十三、IO多路复用" class="headerlink" title="十三、IO多路复用"></a>十三、IO多路复用</h2><p>前面是用协程实现的IO阻塞自动切换，那么协程又是怎么实现的，在原理是是怎么实现的。如何去实现事件驱动的情况下IO的自动阻塞的切换，这个学名叫什么呢？ =&gt; IO多路复用<br>比如socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。<br>　<br>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 </p>
<blockquote>
<p>本文讨论的背景是Linux环境下的network IO。</p>
</blockquote>
<h3 id="1-IO模型前戏准备"><a href="#1-IO模型前戏准备" class="headerlink" title="1 IO模型前戏准备"></a><strong>1 IO模型前戏准备</strong></h3><p>在进行解释之前，首先要说明几个概念：</p>
<ol>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ol>
<h4 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<br>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<br>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。<br>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 </p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。<br>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<p>保存处理机上下文，包括程序计数器和其他寄存器。</p>
<p>更新PCB信息。</p>
<p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>
<p>选择另一个进程执行，并更新其PCB。</p>
<p>更新内存管理的数据结构。</p>
<p>恢复处理机上下文。<br>注：总而言之就是很耗资源的</p>
<h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<h4 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h4 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝 </p>
<p>思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？<br>内核不能信任任何用户空间的指针。必须对用户空间的指针指向的数据进行验证。如果只做验证不做拷贝的话，那么在随后的运行中要随时受到其它进／线程可能修改用户空间数据的威胁。所以必须做拷贝。</p>
<p>缓存 I/O 的缺点： </p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p>​       同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。<br>本文讨论的背景是Linux环境下的network IO。 </p>
<p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li><ul>
<li><ul>
<li>​    blocking IO</li>
<li>​    nonblocking IO</li>
<li>​    IO multiplexing</li>
<li>​    signal driven IO</li>
<li>​    asynchronous IO</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。<br>再说一下IO发生时涉及的对象和步骤。<br>      对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br> 1 等待数据准备 (Waiting for the data to be ready)<br> 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p>
<h3 id="2-blocking-IO-（阻塞IO）"><a href="#2-blocking-IO-（阻塞IO）" class="headerlink" title="2 blocking IO （阻塞IO）"></a>2 blocking IO （阻塞IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="image/0_1280550787I2K8.gif" alt="img"></p>
<p>​      当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="3-non-blocking-IO（非阻塞IO）"><a href="#3-non-blocking-IO（非阻塞IO）" class="headerlink" title="3 non-blocking IO（非阻塞IO）"></a>3 non-blocking IO（非阻塞IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="image/0_128055089469yL.gif" alt="img"></p>
<p>​      从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p>
<p> 注意：</p>
<p>​      在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。<strong>即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，</strong></p>
<p>​      也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<h3 id="4-IO-multiplexing（IO多路复用）"><a href="#4-IO-multiplexing（IO多路复用）" class="headerlink" title="4  IO multiplexing（IO多路复用）"></a>4  IO multiplexing（IO多路复用）</h3><p>​      IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><img src="image/0_1280551028YEeQ.gif" alt="img"></p>
<p>​      当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”select负责的所有socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>注意1：select函数返回结果中如果有文件可读了，那么进程就可以通过调用accept()或recv()来让kernel将位于内核中准备到的数据copy到用户区。</p>
<p>注意2: select的优势在于可以处理多个连接，不适用于单个连接</p>
<h3 id="5-Asynchronous-I-O（异步IO）"><a href="#5-Asynchronous-I-O（异步IO）" class="headerlink" title="5  Asynchronous I/O（异步IO）"></a><strong>5  Asynchronous I/O（异步IO）</strong></h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="image/0_1280551287S777.gif" alt="img"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>​      到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>    <strong>A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;    An asynchronous I/O operation does not cause the requesting process to be blocked;</strong><br>      两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p>​       注意：由于咱们接下来要讲的select，poll，epoll都属于IO多路复用，而IO多路复用又属于同步的范畴，故，epoll只是一个伪异步而已。</p>
<p>各个IO Model的比较如图所示：</p>
<p><img src="image/0_1280551552NVgW.gif" alt="img"></p>
<p>​      经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>五种IO模型比较：</p>
<p>​      <img src="image/877318-20160731161330028-1449419644.png" alt="img"> </p>
<h3 id="6-select-poll-epoll-IO多路复用介绍"><a href="#6-select-poll-epoll-IO多路复用介绍" class="headerlink" title="6 select poll epoll IO多路复用介绍"></a>6 <strong>select poll epoll IO多路复用介绍</strong></h3><p><strong>首先列一下，sellect、poll、epoll三者的区别</strong></p>
<ul>
<li><p><strong>select</strong><br>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br><strong>select目前几乎在所有的平台上支持</strong><br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
</li>
<li><p><strong>poll</strong><br>它和select在本质上没有多大差别，但是poll<strong>没有最大文件描述符数量的限制</strong>。<br>一般也不用它，相当于过渡阶段</p>
</li>
<li><p><strong>epoll</strong><br>直到Linux2.6才出现了由<strong>内核直接支持的实现方法</strong>，那就是epoll。被公认为Linux2.6下性能最好的多路I/O就绪通知方法。windows不支持 </p>
<p>没有最大文件描述符数量的限制。<br>比如100个连接，有两个活跃了，epoll会告诉用户这两个两个活跃了，直接取就ok了，而select是循环一遍。 </p>
<p>（了解）epoll可以<strong>同时支持水平触发和边缘触发</strong>（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 </p>
<p>所以市面上上见到的所谓的异步IO，比如nginx、Tornado、等，我们叫它异步IO，实际上是IO多路复用。</p>
</li>
</ul>
<p><strong>select与epoll</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"># 首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。</span><br><span class="line"># 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</span><br><span class="line"># 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假</span><br><span class="line"># 定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是</span><br><span class="line"># 服务器还没有把数据传回来），这时候该怎么办？</span><br><span class="line"># 阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干</span><br><span class="line"># （或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话</span><br><span class="line"># （假定一定能叫醒你）。</span><br><span class="line"># 非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂</span><br><span class="line"># 个电话：“你到了没？”</span><br><span class="line"># 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</span><br><span class="line"># 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，</span><br><span class="line"># 就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</span><br><span class="line">#</span><br><span class="line"># 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为</span><br><span class="line"># 了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进</span><br><span class="line"># 行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</span><br><span class="line"># 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</span><br><span class="line"># 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变</span><br><span class="line"># 到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</span><br><span class="line"># 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写</span><br><span class="line"># 入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候</span><br><span class="line"># 会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</span><br><span class="line"># 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从</span><br><span class="line"># 长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</span><br><span class="line"># 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告</span><br><span class="line"># 诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</span><br><span class="line"># 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四</span><br><span class="line"># 个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是</span><br><span class="line"># 什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</span><br><span class="line">#</span><br><span class="line"># 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多</span><br><span class="line"># 个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</span><br><span class="line"># 于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞</span><br><span class="line"># 模式再此不予讨论）：</span><br><span class="line"># while true &#123;</span><br><span class="line"># for i in stream[]; &#123;</span><br><span class="line"># if i has data</span><br><span class="line"># read until unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"># 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为</span><br><span class="line"># 如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻</span><br><span class="line"># 塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</span><br><span class="line">#</span><br><span class="line"># 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不</span><br><span class="line"># 过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻</span><br><span class="line"># 塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可</span><br><span class="line"># 以把“忙”字去掉了）。代码长这样:</span><br><span class="line"># while true &#123;</span><br><span class="line"># select(streams[])</span><br><span class="line"># for i in streams[] &#123;</span><br><span class="line"># if i has data</span><br><span class="line"># read until unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"># 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知</span><br><span class="line"># 道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，</span><br><span class="line"># 找出能读出数据，或者写入数据的流，对他们进行操作。</span><br><span class="line"># 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次</span><br><span class="line"># 说了这么多，终于能好好解释epoll了</span><br><span class="line"># epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我</span><br><span class="line"># 们。此时我们对这些流的操作都是有意义的。</span><br><span class="line"># 在讨论epoll的实现细节之前，先把epoll的相关操作列出：</span><br><span class="line"># epoll_create 创建一个epoll对象，一般epollfd = epoll_create()</span><br><span class="line"># epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件</span><br><span class="line"># 比如</span><br><span class="line"># epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回</span><br><span class="line"># epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回</span><br><span class="line"># epoll_wait(epollfd,...)等待直到注册的事件发生</span><br><span class="line"># （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。</span><br><span class="line"># 而epoll只关心缓冲区非满和缓冲区非空事件）。</span><br><span class="line"># 一个epoll模式的代码大概的样子是：</span><br><span class="line"># while true &#123;</span><br><span class="line"># active_stream[] = epoll_wait(epollfd)</span><br><span class="line"># for i in active_stream[] &#123;</span><br><span class="line"># read or write till unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举个例子:</span><br><span class="line">#    select:</span><br><span class="line">#          班里三十个同学在考试,谁先做完想交卷都要通过按钮来活动,他按按钮作为老师的我桌子上的灯就会变红.</span><br><span class="line">#          一旦灯变红,我(select)我就可以知道有人交卷了,但是我并不知道谁交的,所以,我必须跟个傻子似的轮询</span><br><span class="line">#          地去问:嘿,是你要交卷吗?然后我就可以以这种效率极低地方式找到要交卷的学生,然后把它的卷子收上来.</span><br><span class="line">#</span><br><span class="line">#    epoll:</span><br><span class="line">#         这次再有人按按钮,我这不光灯会亮,上面还会显示要交卷学生的名字.这样我就可以直接去对应学生那收卷就</span><br><span class="line">#         好了.当然,同时可以有多人交卷.</span><br></pre></td></tr></table></figure>

<p><strong>IO多路复用的触发方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 在linux的IO多路复用中有水平触发,边缘触发两种模式,这两种模式的区别如下:</span><br><span class="line">#</span><br><span class="line"># 水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,</span><br><span class="line"># 没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.</span><br><span class="line">#</span><br><span class="line"># 边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能</span><br><span class="line"># 多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述</span><br><span class="line"># 符.信号驱动式IO就属于边缘触发.</span><br><span class="line">#</span><br><span class="line"># epoll既可以采用水平触发,也可以采用边缘触发.</span><br><span class="line">#</span><br><span class="line"># 大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时</span><br><span class="line"># 读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边</span><br><span class="line"># 缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,</span><br><span class="line"># 直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面我们还从电子的角度来解释一下:</span><br><span class="line"># </span><br><span class="line">#     水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要</span><br><span class="line"># 有数据可读(描述符就绪)那么水平触发的epoll就立即返回.</span><br><span class="line"># </span><br><span class="line">#     边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据</span><br><span class="line"># 可读,但是没有新的IO活动到来,epoll也不会立即返回.</span><br></pre></td></tr></table></figure>

<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a><strong>简单实例</strong></h3><p><strong>实例1(non-blocking IO)：</strong>     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import socket</span><br><span class="line">sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">sk.setsockopt</span><br><span class="line">sk.bind((&#x27;127.0.0.1&#x27;,6667))</span><br><span class="line">sk.listen(5)</span><br><span class="line">sk.setblocking(False)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (&#x27;waiting client connection .......&#x27;)</span><br><span class="line">        connection,address = sk.accept()   # 进程主动轮询</span><br><span class="line">        print(&quot;+++&quot;,address)</span><br><span class="line">        client_messge = connection.recv(1024)</span><br><span class="line">        print(str(client_messge,&#x27;utf8&#x27;))</span><br><span class="line">        connection.close()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (e)</span><br><span class="line">        time.sleep(4)</span><br><span class="line"></span><br><span class="line">#############################client</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import socket</span><br><span class="line">sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    sk.connect((&#x27;127.0.0.1&#x27;,6667))</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    sk.sendall(bytes(&quot;hello&quot;,&quot;utf8&quot;))</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>

<p>​      优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>
<p>　　缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
<p>实例2(IO multiplexing):</p>
<p>在非阻塞实例中，轮询的主语是进程，而“后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。不过，这个监听的重任通过调用select等函数交给了内核去做。IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvfrom系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p>
<p><strong>实例2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">sk=socket.socket()</span><br><span class="line">sk.bind((&quot;127.0.0.1&quot;,9904))</span><br><span class="line">sk.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    r,w,e=select.select([sk,],[],[],5)</span><br><span class="line">    for i in r:</span><br><span class="line">        # conn,add=i.accept()</span><br><span class="line">        #print(conn)</span><br><span class="line">        print(&quot;hello&quot;)</span><br><span class="line">    print(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&#x27;)</span><br><span class="line">    </span><br><span class="line">#*************************client.py</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sk=socket.socket()</span><br><span class="line"></span><br><span class="line">sk.connect((&quot;127.0.0.1&quot;,9904))</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    inp=input(&quot;&gt;&gt;&quot;).strip()</span><br><span class="line">    sk.send(inp.encode(&quot;utf8&quot;))</span><br><span class="line">    data=sk.recv(1024)</span><br><span class="line">    print(data.decode(&quot;utf8&quot;))</span><br></pre></td></tr></table></figure>

<p>请思考：为什么不调用accept，会反复print？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select属于水平触发</span><br></pre></td></tr></table></figure>

<p><strong>实例3(server端并发聊天):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#***********************server.py</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">sk=socket.socket()</span><br><span class="line">sk.bind((&quot;127.0.0.1&quot;,8801))</span><br><span class="line">sk.listen(5)</span><br><span class="line">inputs=[sk,]</span><br><span class="line">while True:</span><br><span class="line">    r,w,e=select.select(inputs,[],[],5)</span><br><span class="line">    print(len(r))</span><br><span class="line"></span><br><span class="line">    for obj in r:</span><br><span class="line">        if obj==sk:</span><br><span class="line">            conn,add=obj.accept()</span><br><span class="line">            print(conn)</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">        else:</span><br><span class="line">            data_byte=obj.recv(1024)</span><br><span class="line">            print(str(data_byte,&#x27;utf8&#x27;))</span><br><span class="line">            inp=input(&#x27;回答%s号客户&gt;&gt;&gt;&#x27;%inputs.index(obj))</span><br><span class="line">            obj.sendall(bytes(inp,&#x27;utf8&#x27;))</span><br><span class="line"></span><br><span class="line">    print(&#x27;&gt;&gt;&#x27;,r)</span><br><span class="line"></span><br><span class="line">#***********************client.py</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">sk=socket.socket()</span><br><span class="line">sk.connect((&#x27;127.0.0.1&#x27;,8801))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    inp=input(&quot;&gt;&gt;&gt;&gt;&quot;)</span><br><span class="line">    sk.sendall(bytes(inp,&quot;utf8&quot;))</span><br><span class="line">    data=sk.recv(1024)</span><br><span class="line">    print(str(data,&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>

<p>文件描述符其实就是咱们平时说的句柄，只不过文件描述符是linux中的概念。注意，我们的accept或recv调用时即向系统发出recvfrom请求</p>
<p>​    (1)  如果内核缓冲区没有数据－－－&gt;等待－－－&gt;数据到了内核缓冲区，转到用户进程缓冲区；</p>
<p>​    (2) 如果先用select监听到某个文件描述符对应的内核缓冲区有了数据，当我们再调用accept或recv时，直接将数据转到用户缓冲区。</p>
<p><img src="image/877318-20160817132355390-1351277519.png" alt="img"></p>
<p>思考1：开启5个client，分别按54321的顺序发送消息，那么server端是按什么顺序回消息的呢？</p>
<p>思考2:  如何在某一个client端退出后，不影响server端和其它客户端正常交流</p>
<p>linux：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if not data_byte:</span><br><span class="line">            inputs.remove(obj)</span><br><span class="line">            continue</span><br></pre></td></tr></table></figure>

<p>win</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">      data_byte=obj.recv(1024)</span><br><span class="line">      print(str(data_byte,&#x27;utf8&#x27;))</span><br><span class="line">      inp=input(&#x27;回答%s号客户&gt;&gt;&gt;&#x27;%inputs.index(obj))</span><br><span class="line">      obj.sendall(bytes(inp,&#x27;utf8&#x27;))</span><br><span class="line">except Exception:</span><br><span class="line">      inputs.remove(obj)</span><br></pre></td></tr></table></figure>



<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>实例4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Alex Li&#x27;</span><br><span class="line"> </span><br><span class="line">import select</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import queue</span><br><span class="line"> </span><br><span class="line"># Create a TCP/IP socket</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(False)</span><br><span class="line"> </span><br><span class="line"># Bind the socket to the port</span><br><span class="line">server_address = (&#x27;localhost&#x27;, 10000)</span><br><span class="line">print(sys.stderr, &#x27;starting up on %s port %s&#x27; % server_address)</span><br><span class="line">server.bind(server_address)</span><br><span class="line"> </span><br><span class="line"># Listen for incoming connections</span><br><span class="line">server.listen(5)</span><br><span class="line"> </span><br><span class="line"># Sockets from which we expect to read</span><br><span class="line">inputs = [ server ]</span><br><span class="line"> </span><br><span class="line"># Sockets to which we expect to write</span><br><span class="line">outputs = [ ]</span><br><span class="line"> </span><br><span class="line">message_queues = &#123;&#125;</span><br><span class="line">while inputs:</span><br><span class="line"> </span><br><span class="line">    # Wait for at least one of the sockets to be ready for processing</span><br><span class="line">    print( &#x27;\nwaiting for the next event&#x27;)</span><br><span class="line">    readable, writable, exceptional = select.select(inputs, outputs, inputs)</span><br><span class="line">    # Handle inputs</span><br><span class="line">    for s in readable:</span><br><span class="line"> </span><br><span class="line">        if s is server:</span><br><span class="line">            # A &quot;readable&quot; server socket is ready to accept a connection</span><br><span class="line">            connection, client_address = s.accept()</span><br><span class="line">            print(&#x27;new connection from&#x27;, client_address)</span><br><span class="line">            connection.setblocking(False)</span><br><span class="line">            inputs.append(connection)</span><br><span class="line"> </span><br><span class="line">            # Give the connection a queue for data we want to send</span><br><span class="line">            message_queues[connection] = queue.Queue()</span><br><span class="line">        else:</span><br><span class="line">            data = s.recv(1024)</span><br><span class="line">            if data:</span><br><span class="line">                # A readable client socket has data</span><br><span class="line">                print(sys.stderr, &#x27;received &quot;%s&quot; from %s&#x27; % (data, s.getpeername()) )</span><br><span class="line">                message_queues[s].put(data)</span><br><span class="line">                # Add output channel for response</span><br><span class="line">                if s not in outputs:</span><br><span class="line">                    outputs.append(s)</span><br><span class="line">            else:</span><br><span class="line">                # Interpret empty result as closed connection</span><br><span class="line">                print(&#x27;closing&#x27;, client_address, &#x27;after reading no data&#x27;)</span><br><span class="line">                # Stop listening for input on the connection</span><br><span class="line">                if s in outputs:</span><br><span class="line">                    outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉</span><br><span class="line">                inputs.remove(s)    #inputs中也删除掉</span><br><span class="line">                s.close()           #把这个连接关闭掉</span><br><span class="line"> </span><br><span class="line">                # Remove message queue</span><br><span class="line">                del message_queues[s]</span><br><span class="line">    # Handle outputs</span><br><span class="line">    for s in writable:</span><br><span class="line">        try:</span><br><span class="line">            next_msg = message_queues[s].get_nowait()</span><br><span class="line">        except queue.Empty:</span><br><span class="line">            # No messages waiting so stop checking for writability.</span><br><span class="line">            print(&#x27;output queue for&#x27;, s.getpeername(), &#x27;is empty&#x27;)</span><br><span class="line">            outputs.remove(s)</span><br><span class="line">        else:</span><br><span class="line">            print( &#x27;sending &quot;%s&quot; to %s&#x27; % (next_msg, s.getpeername()))</span><br><span class="line">            s.send(next_msg)</span><br><span class="line">    # Handle &quot;exceptional conditions&quot;</span><br><span class="line">    for s in exceptional:</span><br><span class="line">        print(&#x27;handling exceptional condition for&#x27;, s.getpeername() )</span><br><span class="line">        # Stop listening for input on the connection</span><br><span class="line">        inputs.remove(s)</span><br><span class="line">        if s in outputs:</span><br><span class="line">            outputs.remove(s)</span><br><span class="line">        s.close()</span><br><span class="line"> </span><br><span class="line">        # Remove message queue</span><br><span class="line">        del message_queues[s]</span><br></pre></td></tr></table></figure>



<p><strong>实例5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。</span><br><span class="line"># 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。</span><br><span class="line">#server端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import select</span><br><span class="line">import socket</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((&#x27;localhost&#x27;,9000))</span><br><span class="line">server.listen(1000)</span><br><span class="line"></span><br><span class="line">server.setblocking(False)  # 设置成非阻塞模式，accept和recv都非阻塞</span><br><span class="line"># 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们</span><br><span class="line"># BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。</span><br><span class="line">msg_dic = &#123;&#125;</span><br><span class="line">inputs = [server,]  # 交给内核、select检测的列表。</span><br><span class="line"># 必须有一个值，让select检测，否则报错提供无效参数。</span><br><span class="line"># 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接</span><br><span class="line">outputs = []  # 你往里面放什么，下一次就出来了</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    readable, writeable, exceptional = select.select(inputs, outputs, inputs)  # 定义检测</span><br><span class="line">    #新来连接                                        检测列表         异常（断开）</span><br><span class="line">    # 异常的也是inputs是： 检测那些连接的存在异常</span><br><span class="line">    print(readable,writeable,exceptional)</span><br><span class="line">    for r in readable:</span><br><span class="line">        if r is server:  # 有数据，代表来了一个新连接</span><br><span class="line">            conn, addr = server.accept()</span><br><span class="line">            print(&quot;来了个新连接&quot;,addr)</span><br><span class="line">            inputs.append(conn)  # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了</span><br><span class="line">            # inputs = [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了</span><br><span class="line">            # 如果server活动，则来了新连接，conn活动则来数据</span><br><span class="line">            msg_dic[conn] = queue.Queue()  # 初始化一个队列，后面存要返回给这个客户端的数据</span><br><span class="line">        else:</span><br><span class="line">            try :</span><br><span class="line">                data = r.recv(1024)  # 注意这里是r，而不是conn，多个连接的情况</span><br><span class="line">                print(&quot;收到数据&quot;,data)</span><br><span class="line">                # r.send(data) # 不能直接发，如果客户端不收，数据就没了</span><br><span class="line">                msg_dic[r].put(data)  # 往里面放数据</span><br><span class="line">                outputs.append(r)  # 放入返回的连接队列里</span><br><span class="line">            except ConnectionResetError as e:</span><br><span class="line">                print(&quot;客户端断开了&quot;,r)</span><br><span class="line">                if r in outputs:</span><br><span class="line">                    outputs.remove(r) #清理已断开的连接</span><br><span class="line">                inputs.remove(r) #清理已断开的连接</span><br><span class="line">                del msg_dic[r] ##清理已断开的连接</span><br><span class="line"></span><br><span class="line">    for w in writeable:  # 要返回给客户端的连接列表</span><br><span class="line">        data_to_client = msg_dic[w].get()  # 在字典里取数据</span><br><span class="line">        w.send(data_to_client)  # 返回给客户端</span><br><span class="line">        outputs.remove(w)  # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。</span><br><span class="line"></span><br><span class="line">    for e in exceptional:  # 如果连接断开，删除连接相关数据</span><br><span class="line">        if e in outputs:</span><br><span class="line">            outputs.remove(e)</span><br><span class="line">        inputs.remove(e)</span><br><span class="line">        del msg_dic[e]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#*************************client</span><br><span class="line">import socket</span><br><span class="line">client = socket.socket()</span><br><span class="line"></span><br><span class="line">client.connect((&#x27;localhost&#x27;, 9000))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd = input(&#x27;&gt;&gt;&gt; &#x27;).strip()</span><br><span class="line">    if len(cmd) == 0 : continue</span><br><span class="line">    client.send(cmd.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    data = client.recv(1024)</span><br><span class="line">    print(data.decode())</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p><strong>实例6:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import selectors</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line">def accept(sock, mask):</span><br><span class="line">    conn, addr = sock.accept()  # Should be ready</span><br><span class="line">    print(&#x27;accepted&#x27;, conn, &#x27;from&#x27;, addr)</span><br><span class="line">    conn.setblocking(False)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line">def read(conn, mask):</span><br><span class="line">    data = conn.recv(1000)  # Should be ready</span><br><span class="line">    if data:</span><br><span class="line">        print(&#x27;echoing&#x27;, repr(data), &#x27;to&#x27;, conn)</span><br><span class="line">        conn.send(data)  # Hope it won&#x27;t block</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;closing&#x27;, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.bind((&#x27;localhost&#x27;, 1234))</span><br><span class="line">sock.listen(100)</span><br><span class="line">sock.setblocking(False)</span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    events = sel.select()</span><br><span class="line">    for key, mask in events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br></pre></td></tr></table></figure>



<p>注：本文最重要的参考文献是Richard Stevens的“<strong>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking</strong> ”      <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s__biz=MzA4MjEyNTA5Mw==&amp;mid=2652563599&amp;idx=1&amp;sn=9781747e54d906c0c140228376e671ed&amp;scene=21#wecha">http://mp.weixin.qq.com/s__biz=MzA4MjEyNTA5Mw==&amp;mid=2652563599&amp;idx=1&amp;sn=9781747e54d906c0c140228376e671ed&amp;scene=21#wecha</a> t_redirect</p>
<p><a target="_blank" rel="noopener" href="https://pymotw.com/2/select/#module-select">https://pymotw.com/2/select/#module-select</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lingfengtengfei/article/details/12392449">http://blog.csdn.net/lingfengtengfei/article/details/12392449</a></p>
<p><a target="_blank" rel="noopener" href="http://www.jb51.net/article/37416.htm">http://www.jb51.net/article/37416.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://pymotw.com/2/select/#module-select">https://pymotw.com/2/select/#module-select</a> </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/25/Abaqus%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90/" rel="prev" title="Abaqus有限元分析">
      <i class="fa fa-chevron-left"></i> Abaqus有限元分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/29/html/" rel="next" title="html">
      html <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E9%9B%B6"><span class="nav-number">1.</span> <span class="nav-text">零零</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E4%B8%9C%E8%A5%BF"><span class="nav-number">1.1.</span> <span class="nav-text">小东西</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%9F%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">星号的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec"><span class="nav-number">1.1.2.</span> <span class="nav-text">exec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">字符串编码方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%9A%84urb%E5%AD%97%E6%AF%8D"><span class="nav-number">1.1.4.</span> <span class="nav-text">字符串前的urb字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.6.</span> <span class="nav-text">深拷贝，浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">字典浅拷贝实例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.6.1.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="nav-number">1.1.6.1.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.6.1.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">更多实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.1.7.</span> <span class="nav-text">字典循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#print%E9%A2%9C%E8%89%B2"><span class="nav-number">1.1.8.</span> <span class="nav-text">print颜色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.9.</span> <span class="nav-text">类设置属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E3%80%81%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">零、文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">一、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">1、匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E5%B0%BE%E8%B0%83%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">2.函数尾调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">3.高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">4.内置函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">二、文件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.</span> <span class="nav-text">1.基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">2.打开方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.</span> <span class="nav-text">三.迭代器协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">1.迭代器协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-for%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">2.for循环机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90"><span class="nav-number">5.3.</span> <span class="nav-text">3.生成器和列表解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">四、装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8E%9F%E5%88%99"><span class="nav-number">6.1.</span> <span class="nav-text">1.原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97"><span class="nav-number">6.2.</span> <span class="nav-text">*解压序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A8%A1%E5%9D%97"><span class="nav-number">7.</span> <span class="nav-text">五、模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tips"><span class="nav-number">7.1.</span> <span class="nav-text">tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.</span> <span class="nav-text">1.内置模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-time%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.1.</span> <span class="nav-text">1.1 time模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-random%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.2.</span> <span class="nav-text">1.2 random模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-os%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.3.</span> <span class="nav-text">1.3 os模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-sys%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.4.</span> <span class="nav-text">1.4 sys模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-Json-amp-Pickel"><span class="nav-number">7.2.5.</span> <span class="nav-text">1.5 Json&amp;Pickel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-shelve"><span class="nav-number">7.2.6.</span> <span class="nav-text">1.5 shelve</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-XML%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.7.</span> <span class="nav-text">1.6 XML模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-re%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.8.</span> <span class="nav-text">1.7 re模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-logging%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.9.</span> <span class="nav-text">1.8 logging模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-configparser%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.10.</span> <span class="nav-text">1.9 configparser模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-hashlib%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.11.</span> <span class="nav-text">1.10 hashlib模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-subprocess%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.12.</span> <span class="nav-text">1.11 subprocess模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-struct-%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.13.</span> <span class="nav-text">1.12 struct 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-partial%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.14.</span> <span class="nav-text">1.13 partial模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-optparse%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.15.</span> <span class="nav-text">1.14 optparse模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-uuid"><span class="nav-number">7.2.16.</span> <span class="nav-text">1.15 uuid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-16-concurrent"><span class="nav-number">7.2.17.</span> <span class="nav-text">1.16 concurrent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-XX-iter%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">7.2.18.</span> <span class="nav-text">1.XX iter的参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.</span> <span class="nav-text">六、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">1. 三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E7%BB%A7%E6%89%BF"><span class="nav-number">8.1.1.</span> <span class="nav-text">1.1继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.2.</span> <span class="nav-text">1.2 子类中调用父类方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%A4%9A%E6%80%81"><span class="nav-number">8.2.</span> <span class="nav-text">1.2 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B0%81%E8%A3%85"><span class="nav-number">8.3.</span> <span class="nav-text">1.3 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#x-python-OOP%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="nav-number">8.3.1.</span> <span class="nav-text">x.python OOP的常用术语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6"><span class="nav-number">8.4.</span> <span class="nav-text">1.4 面向对象进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97"><span class="nav-number">8.4.1.</span> <span class="nav-text">1.4.1动态导入模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E5%BC%80%E5%A4%B4%E7%9A%84attr%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">1.4.2 双下划线开头的attr方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-getattribute"><span class="nav-number">8.4.3.</span> <span class="nav-text">1.4.3 __getattribute__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E6%8E%88%E6%9D%83"><span class="nav-number">8.4.4.</span> <span class="nav-text">1.4.4 授权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-isinstance-obj-cls-%E5%92%8Cissubclass-sub-super"><span class="nav-number">8.4.5.</span> <span class="nav-text">1.4.5 isinstance(obj,cls)和issubclass(sub,super)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-6-setitem-getitem-delitem"><span class="nav-number">8.4.6.</span> <span class="nav-text">1.4.6 __setitem__,__getitem__,__delitem__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-7-str-repr-format"><span class="nav-number">8.4.7.</span> <span class="nav-text">1.4.7 __str__,__repr__,__format__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-8-slot"><span class="nav-number">8.4.8.</span> <span class="nav-text">1.4.8 __slot__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-9-doc"><span class="nav-number">8.4.9.</span> <span class="nav-text">1.4.9 __doc__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-10-module-%E5%92%8C-class"><span class="nav-number">8.4.10.</span> <span class="nav-text">1.4.10 __module__和__class__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-11-del"><span class="nav-number">8.4.11.</span> <span class="nav-text">1.4.11 __del__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-12-call"><span class="nav-number">8.4.12.</span> <span class="nav-text">1.4.12 __call__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-13-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.13.</span> <span class="nav-text">1.4.13 迭代器协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-14-%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88-get-set-delete-%EF%BC%89"><span class="nav-number">8.4.14.</span> <span class="nav-text">1.4.14 描述符（__get__,__set__,__delete__）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-15-enter-exit"><span class="nav-number">8.4.15.</span> <span class="nav-text">1.4.15 __enter__&#x2F;__exit__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-16-%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">8.4.16.</span> <span class="nav-text">1.4.16 类的装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-17-%E5%86%8D%E7%9C%8Bproperty"><span class="nav-number">8.4.17.</span> <span class="nav-text">1.4.17 再看property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-18-%E5%85%83%E7%B1%BB-metaclass"><span class="nav-number">8.4.18.</span> <span class="nav-text">1.4.18 元类 metaclass</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#class%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">8.4.18.1.</span> <span class="nav-text">class关键字创建类的流程分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E6%8E%A7%E5%88%B6%E7%B1%BBOldboyTeacher%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">8.4.18.2.</span> <span class="nav-text">自定义元类控制类OldboyTeacher的调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%8D%E7%9C%8B%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="nav-number">8.4.18.3.</span> <span class="nav-text">再看属性查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83"><span class="nav-number">8.5.</span> <span class="nav-text">2. 软件目录结构规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">8.5.1.</span> <span class="nav-text">为什么要设计好目录结构?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-number">8.5.2.</span> <span class="nav-text">目录组织方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EREADME%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">8.5.3.</span> <span class="nav-text">关于README的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Erequirements-txt%E5%92%8Csetup-py"><span class="nav-number">8.5.4.</span> <span class="nav-text">关于requirements.txt和setup.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-py"><span class="nav-number">8.5.5.</span> <span class="nav-text">setup.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#requirements-txt"><span class="nav-number">8.5.6.</span> <span class="nav-text">requirements.txt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.7.</span> <span class="nav-text">关于配置文件的使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%9C%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%AD%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%B0%86conf-py%E6%94%BE%E5%9C%A8%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E8%80%8C%E6%98%AF%E6%94%BE%E5%9C%A8docs-%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82"><span class="nav-number">8.5.8.</span> <span class="nav-text">注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs&#x2F;目录下。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">七、异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81socket%E7%BC%96%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">八、socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">10.1.</span> <span class="nav-text">一 客户端&#x2F;服务器架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-osi%E4%B8%83%E5%B1%82"><span class="nav-number">10.2.</span> <span class="nav-text">二 osi七层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-socket%E5%B1%82"><span class="nav-number">10.3.</span> <span class="nav-text">三 socket层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-socket%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">10.4.</span> <span class="nav-text">四 socket是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%91%E5%B1%95%E5%8F%B2%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="nav-number">10.5.</span> <span class="nav-text">五 套接字发展史及分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">10.6.</span> <span class="nav-text">六 套接字工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">10.7.</span> <span class="nav-text">七 基于TCP的套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">10.8.</span> <span class="nav-text">八 基于UDP的套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D-%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-number">10.9.</span> <span class="nav-text">九 粘包现象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85"><span class="nav-number">10.10.</span> <span class="nav-text">十 什么是粘包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E7%9A%84low%E6%AF%94%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">10.11.</span> <span class="nav-text">十一 解决粘包的low比处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-%E5%B3%B0%E5%93%A5%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.12.</span> <span class="nav-text">十二 峰哥解决粘包的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%89-%E8%AE%A4%E8%AF%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%93%BE%E6%8E%A5%E5%90%88%E6%B3%95%E6%80%A7"><span class="nav-number">10.13.</span> <span class="nav-text">十三 认证客户端的链接合法性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B-socketserver%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91"><span class="nav-number">10.14.</span> <span class="nav-text">十四 socketserver实现并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FTP"><span class="nav-number">10.14.1.</span> <span class="nav-text">FTP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91"><span class="nav-number">11.</span> <span class="nav-text">九、并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91-amp-%E5%B9%B6%E8%A1%8C"><span class="nav-number">11.1.</span> <span class="nav-text">并发&amp;并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5"><span class="nav-number">11.2.</span> <span class="nav-text">同步&amp;异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">11.3.</span> <span class="nav-text">python多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python%E7%9A%84GIL"><span class="nav-number">11.4.</span> <span class="nav-text">python的GIL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81python%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8Ethreading%E6%A8%A1%E5%9D%97"><span class="nav-number">12.</span> <span class="nav-text">十、python的线程与threading模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">12.1.</span> <span class="nav-text">一 线程的两种调用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-threading-thread%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">二 threading.thread的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join-amp-Daemon%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.1.</span> <span class="nav-text">join&amp;Daemon方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.2.</span> <span class="nav-text">其它方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E5%90%8C%E6%AD%A5%E9%94%81-Lock"><span class="nav-number">12.3.</span> <span class="nav-text">三 同步锁(Lock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E5%92%8C%E9%80%92%E5%BD%92%E9%94%81"><span class="nav-number">12.4.</span> <span class="nav-text">四 线程死锁和递归锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6-Event"><span class="nav-number">12.5.</span> <span class="nav-text">同步条件(Event)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="nav-number">12.6.</span> <span class="nav-text">信号量(Semaphore)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%A9%E5%99%A8%EF%BC%8D%EF%BC%8D%EF%BC%8D%E9%98%9F%E5%88%97-queue"><span class="nav-number">12.7.</span> <span class="nav-text">多线程利器－－－队列(queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">12.7.1.</span> <span class="nav-text">列表是不安全的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#queue%E5%88%97%E9%98%9F%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">12.7.2.</span> <span class="nav-text">queue列队类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#task-done-amp-join"><span class="nav-number">12.7.3.</span> <span class="nav-text">task_done()&amp;join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">12.7.4.</span> <span class="nav-text">生产者消费者模型：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9D%97-multiprocessing"><span class="nav-number">13.</span> <span class="nav-text">多进程模块 multiprocessing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">13.1.</span> <span class="nav-text">一 进程的调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F1"><span class="nav-number">13.1.1.</span> <span class="nav-text">调用方式1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F2"><span class="nav-number">13.1.2.</span> <span class="nav-text">调用方式2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-Process%E7%B1%BB"><span class="nav-number">13.2.</span> <span class="nav-text">二 Process类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="nav-number">13.3.</span> <span class="nav-text">三 进程间通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E5%AF%B9%E5%88%97Queue"><span class="nav-number">13.3.1.</span> <span class="nav-text">3.1 进程对列Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%AE%A1%E9%81%93"><span class="nav-number">13.3.2.</span> <span class="nav-text">3.2 管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Managers-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">13.3.3.</span> <span class="nav-text">3.3 Managers(数据共享)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">13.4.</span> <span class="nav-text">四 进程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-number">13.5.</span> <span class="nav-text">五 进程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Python%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8-contextlib%E6%A8%A1%E5%9D%97"><span class="nav-number">14.</span> <span class="nav-text">四 Python中的上下文管理器(contextlib模块)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%9A"><span class="nav-number">14.1.</span> <span class="nav-text">1 如何使用上下文管理器：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">14.2.</span> <span class="nav-text">2 自定义上下文管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-contextlib%E6%A8%A1%E5%9D%97"><span class="nav-number">14.3.</span> <span class="nav-text">3 contextlib模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-contextlib-nested-%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97"><span class="nav-number">14.4.</span> <span class="nav-text">4 contextlib.nested:减少嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-contextlib-closing"><span class="nav-number">14.5.</span> <span class="nav-text">5 contextlib.closing()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">十一、协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#yield%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">15.1.</span> <span class="nav-text">yield的简单实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Greenlet"><span class="nav-number">15.2.</span> <span class="nav-text">Greenlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gevent"><span class="nav-number">15.3.</span> <span class="nav-text">Gevent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">16.</span> <span class="nav-text">十二、IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">16.1.</span> <span class="nav-text">事件驱动模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">16.2.</span> <span class="nav-text">一、事件驱动模型介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB"><span class="nav-number">16.2.1.</span> <span class="nav-text">1创建一个线程循环检测是否有鼠标点击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B0%B1%E6%98%AF%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">16.2.2.</span> <span class="nav-text">2 就是事件驱动模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">17.</span> <span class="nav-text">十三、IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-IO%E6%A8%A1%E5%9E%8B%E5%89%8D%E6%88%8F%E5%87%86%E5%A4%87"><span class="nav-number">17.1.</span> <span class="nav-text">1 IO模型前戏准备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">17.1.1.</span> <span class="nav-text">用户空间与内核空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">17.1.2.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="nav-number">17.1.3.</span> <span class="nav-text">进程的阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd"><span class="nav-number">17.1.4.</span> <span class="nav-text">文件描述符fd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-I-O"><span class="nav-number">17.1.5.</span> <span class="nav-text">缓存 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-blocking-IO-%EF%BC%88%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="nav-number">17.2.</span> <span class="nav-text">2 blocking IO （阻塞IO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-non-blocking-IO%EF%BC%88%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="nav-number">17.3.</span> <span class="nav-text">3 non-blocking IO（非阻塞IO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-IO-multiplexing%EF%BC%88IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%89"><span class="nav-number">17.4.</span> <span class="nav-text">4  IO multiplexing（IO多路复用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Asynchronous-I-O%EF%BC%88%E5%BC%82%E6%AD%A5IO%EF%BC%89"><span class="nav-number">17.5.</span> <span class="nav-text">5  Asynchronous I&#x2F;O（异步IO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-select-poll-epoll-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">17.6.</span> <span class="nav-text">6 select poll epoll IO多路复用介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">17.7.</span> <span class="nav-text">简单实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8"><span class="nav-number">17.8.</span> <span class="nav-text">延伸</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xue Xuan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Xue Xuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sjtu-xx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sjtu-xx" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xuexuan1997@gmail.com" title="E-Mail → mailto:xuexuan1997@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xue Xuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'eMthrkXxWi9VDSG39hpPXkOi-gzGzoHsz',
      appKey     : '40yWQRY3985h43auodOGjsIQ',
      placeholder: "欢迎畅所欲言",
      avatar     : 'ヾﾉ≧∀≦)o来啊，快活啊!',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
